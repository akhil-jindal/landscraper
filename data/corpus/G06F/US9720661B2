Selectively controlling use of extended mode features 
US-9720661-B2
International Businesss Machines Corporation
2017-08-01
https://patents.google.com/patent/US9720661B2/en
BACKGROUND
One or more aspects relate, in general, to processing within a computing environment, and in particular, to managing such processing.
Opportunities to improve the operation of computer systems are provided by a number of code rewriting techniques. For example, code rewriting may be used to modify binaries to avoid known hardware errors. In other examples, existing code may be modified to improve performance by re-optimizing hot regions, either from binary code, or from additional internal representation formats stored by the static compiler that allow code to be re-optimized without decompiling the binary code.
Various offline optimizers have been used to rewrite code. These optimizers modify the actual binary, making self-referential programs, including those that compute checksums of their own code to validate correctness, fail. These offline optimizers also depend on obtaining workload statistics.
Other optimization techniques, such as dynamic code optimization, also rewrite code. These techniques, however, recompile code dynamically and store the newly generated code in its entirety in locations different from the original code to preserve such self-referential behavior.
SUMMARY
Shortcomings of the prior art are overcome and advantages are provided through the provision of a computer program product for facilitating processing in a computing environment. The computer program product includes a computer readable storage medium readable by a processing circuit and storing instructions for execution by the processing circuit for performing a method. The method includes, for instance, generating, by an optimizer, modified code of an application, wherein the application comprises unmodified code and modified code; and based on generating the modified code, setting by the optimizer one or more controls to selectively enable use of extended mode features by the application, the extended mode features comprising one or more features at an instruction set level different from an instruction set level available to the application.
Methods and systems relating to one or more embodiments are also described and claimed herein. Further, services relating to one or more embodiments are also described and may be claimed herein.
Additional features and advantages are realized. Other embodiments and aspects are described in detail herein and are considered a part of the claimed invention.

BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS
One or more aspects are particularly pointed out and distinctly claimed as examples in the claims at the conclusion of the specification. The foregoing and other objects, features, and advantages are apparent from the following detailed description taken in conjunction with the accompanying drawings in which:
 FIG. 1 depicts one example of a computing environment to incorporate and use one or more aspects of a dynamic code optimization capability that selectively provides extended mode features;
 FIG. 2 depicts another example of a computing environment to incorporate and use one or more aspects of a dynamic code optimization capability that selectively provides extended mode features;
 FIG. 3A depicts yet another example of a computing environment to incorporate and use one or more aspects of a dynamic code optimization capability that selectively provides extended mode features;
 FIG. 3B depicts further details of the memory of FIG. 3A;
 FIG. 4 depicts one example of a computing environment including patched application code;
 FIG. 5 illustrates an example of a high-level view of a virtual memory mapped to a physical memory using a hash page table technique;
 FIG. 6 depicts one example in which one effective address is able to be translated to different physical addresses;
 FIG. 7 depicts one embodiment of an address translation process;
 FIG. 8 depicts one embodiment of logic to translate an effective address to a virtual address;
 FIG. 9 pictorially depicts one embodiment of translating an effective address to a virtual address;
 FIG. 10 depicts one example of a hash page table translation structure;
 FIG. 11 depicts one example of an effective address being translated to separate physical addresses;
 FIG. 12 depicts examples of translating effective addresses to physical addresses;
 FIG. 13A depicts one example of a control register;
 FIG. 13B depicts one example of a machine state register;
 FIG. 13C depicts one example of an entry of an address translation structure;
 FIG. 13D depicts one example of a page table entry;
 FIG. 13E depicts one example of a storage key;
 FIG. 13F depicts one example of a single extended mode control in a page table entry and multiple individual extended mode controls in a control register;
 FIG. 14A depicts one embodiment of logic to create optimized code;
 FIG. 14B depicts another embodiment of logic to create optimized code that enables extended mode features;
 FIG. 15 depicts one embodiment of using optimized code that takes advantage of extended mode features;
 FIG. 16A depicts one example format of a move from machine state register (mfmsr) instruction;
 FIG. 16B depicts one example format of a move to machine state register (mtmsr) instruction;
 FIG. 17 depicts one embodiment of a computer program product;
 FIG. 18 depicts one embodiment of a host computer system;
 FIG. 19 depicts a further example of a computer system;
 FIG. 20 depicts another example of a computer system comprising a computer network;
 FIG. 21 depicts one embodiment of various elements of a computer system;
 FIG. 22A depicts one embodiment of the execution unit of the computer system of FIG. 21;
 FIG. 22B depicts one embodiment of the branch unit of the computer system of FIG. 21;
 FIG. 22C depicts one embodiment of the load/store unit of the computer system of FIG. 21;
 FIG. 23 depicts one embodiment of an emulated host computer system;
 FIG. 24 depicts one embodiment of a cloud computing node;
 FIG. 25 depicts on embodiment of a cloud computing environment; and
 FIG. 26 depicts one example of abstraction model layers.

DETAILED DESCRIPTION
Dynamic code optimization (DCO) offers significant opportunities to improve the operation of computer systems. For example, existing code can be modified to improve performance by re-optimizing hot regions, either from binary code, or from additional internal representation formats stored by the static compiler that allows a re-optimization component to re-optimize code without decompiling the binary code. As other examples, dynamic code optimization may be used to avoid or fix errors, enhance security, provide additional features, etc.
With dynamic code optimization, in accordance with one or more aspects, one or more portions of application code are modified (e.g., changed, revised, enhanced, updated, optimized, etc.), and therefore, the application code is considered patched (i.e., existing code is used along with the modifications). A portion of the code to be modified is copied, modified, and stored in one or more memory regions (e.g., pages of memory) that are separate from the memory regions storing the pre-existing or unmodified application code.
When code is patched, in accordance with one or more aspects, separate address translation is provided, which depends, for instance, on whether the translation is for an instruction fetch or a data access. For instance, data accesses (e.g., address translation for data accesses) are directed to the unmodified code (i.e., one or more first memory regions), while code translation (e.g., address translation for instruction fetches) is directed to the modified code (i.e., one or more second memory regions). Additionally, instruction fetches and data accesses for code of the application that has not been copied are directed to the same pre-existing code, which are also stored in the one or more first memory regions, in this example. This separate address translation is accomplished by, for instance, hardware support that selectively manages separate instruction and data translation within a processor, enabling only portions (e.g., modified portions) of the code to be duplicated rather than the entire code.
In accordance with one or more aspects, dynamic code optimization offers an opportunity to exploit additional features or execution modes (referred to herein as extended mode features) offered by a machine and not otherwise available, known or being used by a program executing on the machine. For instance, an application program is developed with a common instruction set architecture (ISA) across multiple generations. Thus, when a specific implementation/micro-architecture offers specific opportunities for optimization, these capabilities are often not made available in the ISA because of compatibility considerations. Even when new features are made available as part of the ISA, the application often uses a back level version of the ISA.
However, in accordance with one aspect, dynamic code optimization may be used to exploit these additional features that were otherwise unavailable, unknown or not used by applications executing on the machine. This is accomplished while preventing other applications from exploiting an ISA level to which it should not have access. In particular, in accordance with one aspect, higher or extended levels of function are made available to code generated by a DCO component and executing with normal application level privilege, but other applications are prevented from executing such instructions.
Computing environments of different architectures may incorporate and use one or more aspects of the dynamic code optimization capability provided herein. For instance, environments based on the PowerPC architecture, also referred to as Power ISA, offered by International Business Machines Corporation (IBMÂ®) and described in Power ISAâ¢ Version 2.07, May 3, 2013, hereby incorporated by reference herein in its entirety, may include one or more aspects, as well as computing environments of other architectures, such as the z/Architecture, offered by International Business Machines Corporation, and described in z/ArchitectureâPrinciples of Operation, Publication No. SA22-7932-09, 10th Edition, September 2012, which is hereby incorporated by reference herein in its entirety.
POWER, POWER ARCHITECTURE, POWERPC, Z/ARCHITECTURE, IBM, AIX, POWERVM, Z/OS and Z/VM (referenced herein) are registered trademarks of International Business Machines Corporation, Armonk, N.Y. Other names used herein may be registered trademarks, trademarks or product names of International Business Machines Corporation or other companies.
One example of a computing environment to incorporate and use one or more aspects of the dynamic code optimization capability, including selectively providing extended mode features, is described with reference to FIG. 1. In one example, a computing environment 100 includes a processor (central processing unitâCPU) 102 that includes at least one memory management unit (MMU) 104, one or more address translation structures 105, and one or more caches 106. Processor 102 is communicatively coupled to a memory portion 108 and to an input/output (I/O) subsystem 112. Memory portion 108 includes, for instance, one or more caches 110 and a dynamic code optimizer (DCO) 111, which may be used to optimize applications executing within the processor. I/O subsystem 112 is communicatively coupled to external I/O devices 114 that may include, for example, data input devices, sensors and/or output devices, such as displays.
Memory management unit 104 is used in managing memory portion 108 including facilitating access to the memory by providing address translation. To improve address translation, the memory management unit utilizes one or more address translation structures 105 including, for instance, a translation lookaside buffer (TLB) and a segment lookaside buffer (SLB) which, in one embodiment, are located in the MMU. The TLB is a cache of previously translated addresses. Thus, when a request is received for a memory access that includes an address to be translated, the TLB is checked first. If the address and its translation are in the TLB, then no further translation process based on using any number of translation techniques is necessary. Otherwise, the received address is translated using one of any number of translation techniques.
A further embodiment of a computing environment to incorporate and use one or more aspects of the dynamic code optimization capability, including selectively providing extended mode features is depicted in FIG. 2. Referring to FIG. 2, in one example, a computing environment 200 includes a central processor complex (CPC) 202 coupled to one or more input/output (I/O) devices 204 via one or more control units 206. Central processor complex 202 includes processor memory 208 (a.k.a., main memory, main storage, central storage) coupled to one or more central processors (a.k.a., central processing units (CPUs)) 210 and an I/O subsystem 212, each of which is further described below.
Processor memory 208 includes one or more virtual machines 214 (for one example of the PowerPC architecture) or one or more logical partitions 214 (for one example of the z/Architecture), and processor firmware 216, which includes a hypervisor 218 and other processor firmware 220. As used herein, firmware includes, e.g., the microcode and/or millicode of the processor. It includes, for instance, the hardware-level instructions and/or data structures used in implementation of higher level machine code. In one embodiment, it includes, for instance, proprietary code that is typically delivered as microcode that includes trusted software or microcode specific to the underlying hardware and controls operating system access to the system hardware.
Each virtual machine or logical partition 214 functions as a separate system and has one or more applications 222, and optionally, a resident operating system 224 therein, which may differ for each virtual machine or logical partition. In one embodiment, the operating system is the z/VM operating system, the z/OS operating system, the z/Linux operating system, the TPF operating system, the AIX operating system, the Power Linux operating system, the IBM i/OS operating system, or another operating system, offered by International Business Machines Corporation, Armonk, N.Y., or another operating system offered by another company. Further, each logical partition or virtual machine may include a dynamic code optimizer 225 or other optimizer that may execute as part of the operating system, part of one or more applications or on its own to provide optimized application code.
The virtual machines are managed by hypervisor 218, such as PowerVM, offered by International Business Machines Corporation, Armonk, N.Y.; and the logical partitions are managed by hypervisor 218, such as the Processor Resource/System Manager (PR/SM), offered by International Business Machines Corporation, Armonk, N.Y.
Central processors 210 are physical processor resources assignable to the virtual machines or allocated to the logical partitions. For instance, each virtual machine or logical partition 214 includes one or more logical processors, each of which represents all or a share of a physical processor 210 that may be dynamically allocated to the virtual machine or partition. A central processor may include a memory management unit (MMU) 230 and one or more address translation structures 231 providing address translation, as described herein, and at least one cache 232.
Input/output subsystem 212 directs the flow of information between input/output devices 204 and main memory 208. It is coupled to the central processing complex, in that it can be a part of the central processing complex or separate therefrom. The I/O subsystem relieves the central processors of the task of communicating directly with the input/output devices and permits data processing to proceed concurrently with input/output processing. To provide communications, the I/O subsystem employs I/O communications adapters. There are various types of communications adapters including, for instance, channels, I/O adapters, PCI cards, Ethernet cards, Small Computer Storage Interface (SCSI) cards, etc. Further, the I/O subsystem uses one or more input/output paths as communication links in managing the flow of information to or from input/output devices 204.
Another embodiment of a computing environment to incorporate and use one or more aspects of the dynamic code optimization capability, including selectively providing extended mode features, is described with reference to FIG. 3A. In this example, a computing environment 300 includes, for instance, a native central processing unit (CPU) 302, a memory 304, and one or more input/output devices and/or interfaces 306 coupled to one another via, for example, one or more buses 308 and/or other connections. As examples, computing environment 300 may include a PowerPC processor, or a Power Systems server offered by International Business Machines Corporation, Armonk, N.Y.; an HP Superdome with Intel Itanium II processors offered by Hewlett Packard Co., Palo Alto, Calif.; and/or other machines based on architectures offered by International Business Machines Corporation, Hewlett Packard, Intel, Oracle, or others.
Native central processing unit 302 includes one or more native registers 310, such as one or more general purpose registers and/or one or more special purpose registers used during processing within the environment, as well as one or more address translation structures 311. These registers include information that represents the state of the environment at any particular point in time.
Moreover, native central processing unit 302 executes instructions and code that are stored in memory 304. In one particular example, the central processing unit executes emulator code 312 stored in memory 304. This code enables the computing environment configured in one architecture to emulate another architecture. For instance, emulator code 312 allows machines based on architectures other than the z/Architecture, such as PowerPC processors, Power Systems servers, HP Superdome servers or others, to emulate the z/Architecture and to execute software and instructions developed based on the z/Architecture, or allows machines based on architectures other than the Power Architecture, such as HP Superdome servers or others, to emulate the Power Architecture and to execute software and instructions developed based on the Power Architecture.
Further details relating to emulator code 312 are described with reference to FIG. 3B. Guest instructions 350 stored in memory 304 comprise software instructions (e.g., correlating to machine instructions) that were developed to be executed in an architecture other than that of native CPU 302. For example, guest instructions 350 may have been designed to execute on a Power Architecture or z/Architecture processor 102, but instead, are being emulated on native CPU 302, which may be, for example, an Intel Itanium II processor. In one example, emulator code 312 includes an instruction fetching routine 352 to obtain one or more guest instructions 350 from memory 304, and to optionally provide local buffering for the instructions obtained. It also includes an instruction translation routine 354 to determine the type of guest instruction that has been obtained and to translate the guest instruction into one or more corresponding native instructions 356. This translation includes, for instance, identifying the function to be performed by the guest instruction and choosing the native instruction(s) to perform that function.
Further, emulator code 312 includes an emulation control routine 360 to cause the native instructions to be executed. Emulation control routine 360 may cause native CPU 302 to execute a routine of native instructions that emulate one or more previously obtained guest instructions and, at the conclusion of such execution, return control to the instruction fetch routine to emulate the obtaining of the next guest instruction or a group of guest instructions. Execution of the native instructions 356 may include loading data into a register from memory 304; storing data back to memory from a register; or performing some type of arithmetic or logic operation, as determined by the translation routine.
Each routine is, for instance, implemented in software, which is stored in memory and executed by native central processing unit 302. In other examples, one or more of the routines or operations are implemented in firmware, hardware, software or some combination thereof. The registers of the emulated processor may be emulated using registers 310 of the native CPU or by using locations in memory 304. In embodiments, guest instructions 350, native instructions 356 and emulator code 312 may reside in the same memory or may be disbursed among different memory devices.
The computing environments described above are only examples of computing environments that can be used. Other environments, including but not limited to, other non-partitioned environments, other partitioned environments, and/or other emulated environments, may be used; embodiments are not limited to any one environment.
Computing environments, such as those described above, are enhanced by including components that alter application programs executing within the environments to provide those application programs with additional features. For instance, a component, referred to as dynamic code optimization (DCO), may be provided that examines programs as they are executing, recognizes frequently executed code segments and optimizes those segments. Other types of optimization are also possible, as well as other types of components. Further, changes may be made to programs for other reasons, such as correcting an error, providing workarounds for known hardware errata, enhancing security, etc.
Changing a program while it is executing is complicated and issues may arise. For instance, if a program references itself, i.e., it is self-referential, it may detect the change and refuse to run or the change may cause it to run improperly due to it being self-referential. An example of a self-referential code may be a binary that validates its own correctness by computing the checksum of its program code, and comparing the computed result with an expected result to avoid tampering. Thus, in accordance with one aspect, a capability is provided that allows applications to be modified, while preserving self-referential integrity.
In one example, for dynamic code optimization, code that is not frequently used is maintained unchanged, and code that is frequently used, referred to as hot spots, are dynamically compiled into optimized code and the pre-existing code is patched to integrate the optimized code into the pre-existing code generating patched code. Then, to transfer to the optimized code, the original binary is modified (patched) by inserting a jump instruction to jump to the optimized code and when done, another jump instruction is inserted to jump back to the original code.
One example of a computing environment that includes patched code is depicted in FIG. 4. This computing environment is based, for instance, on the PowerPC architecture offered by International Business Machines Corporation, however many other systems may incorporate and use one or more of the aspects described herein. As shown, a computing environment 400 includes, for instance, a processor 402 coupled to a memory 404 via one or more caches 406, 408. Memory 404 is, for instance, random access memory, having a plurality of portions, including, for example, system memory 410, data memory 412, and code memory 414 (also referred to as instruction memory). In one example, system memory 410 includes application code, including, for instance, patched application code 420, and/or data for one or more applications; data memory 412 is memory used by, for instance, an optimizer; and code memory 414 is, for instance, code of the optimizer. Code memory 414 is coupled to instruction cache 406 accessed by processor 402; and data memory 412 and system memory 410 are coupled to data cache 408 accessed by processor 402. Further, system memory 410, including patched application code 420, is also coupled to instruction cache 406.
In particular, in one embodiment, system memory 410 includes, for instance, application code for one or more applications, including patched application code 420. For example, application code for a particular application is stored in one or more memory regions (e.g., pages) of system memory 410. If the particular application is modified, then it is referred to as patched application code, which includes the existing code plus the modified code. From a memory viewpoint, the portions of the patched application code that have not been modified continue to be stored in the same memory regions as the pre-existing application code, and any duplicated or modified code is stored in one or more memory regions of system memory 410 separate from the memory regions of the pre-existing or unmodified application code.
Since the patched application code includes modified code located in one or more separate memory regions and since, in one embodiment, this modified code is to be hidden from data accesses, separate address translations for instruction fetches and data accesses relating to the modified code are provided, as described below. The use of separate address translations for instruction/data accesses, in conjunction with the memory mapping of FIG. 4, allows the view of memory from the instruction fetcher to be fenced off, enabling the use of patched code while maintaining referential integrity.
Details regarding physical memory used by one or more of the computing environments described herein and access thereto are described with reference to FIG. 5. As is known, physical memory is of a defined size and in order to have the physical memory appear larger than it is, virtual memory is utilized. One example of a high-level view of virtual memory 501 mapped to a physical memory 503 (such as memory 108, 208, 304, 404 or a portion thereof) is depicted in FIG. 5. In this example, the mapping from virtual memory to real memory is via a hash page table (HPT) technique 505 to locate page table entries (PTEs), as used by, for example, Power ISA. In this example, programs only use sections (or segments) A and B of the virtual memory. Each segment of the virtual memory is mapped to a segment identifier (SID) entry 507 identified by an effective segment ID (ESID) (ESIDs for B and ESIDs for A included). An âeffective addressâ 504 used by the program selects an SID entry, which includes the ESID value, as well as a virtual segment ID (VSID) 514 value. The VSID value represents the high-order bits of a virtual address to be used by hashing algorithm 505 to search the hash page table. A hashed value based on the VSID is used to locate a page table entry (PTE). The page table entry includes an address 513 of a page of physical memory 503.
As indicated above, an effective address is used to obtain a physical address in order to access a particular memory location. In accordance with one aspect, as depicted in FIG. 6, one effective address 600 in an effective address space 602 may translate to multiple physical addresses 604 a, 604 b of a physical address space 606 depending on whether the translation is for an instruction translation 608 or a data translation 610. In particular, in one embodiment, separate address translation (i.e., separate instruction and data translation) may be used in certain situations, such as for instance, when code has been modified, but the modified code is to be hidden from data accesses. In such a situation, the modified code is placed in a separate memory region at a different physical address than the unmodified code, and the physical address of the separate memory region is determined via address translation for instruction fetches. The unmodified code, however, is still accessed by data accesses, which use address translations for data accesses that point to another physical address (i.e., of the unmodified code). This allows, for instance, the view of memory the instruction fetcher sees to be fenced off from the view of the data accesses. For those situations, where the code is unchanged, address translation for instruction fetches and data accesses point to the same physical memory locations. These locations are referred to as being shared for instruction fetches and data accesses.
In accordance with one aspect, an address translation capability is described in which the address translation takes into consideration whether the memory access is for an instruction fetch or a data access. One embodiment of address translation is described with reference to FIGS. 7-10. The particular example described herein is for the PowerPC architecture; however, aspects of the address translation capability are not limited to such an architecture.
Initially, referring to FIG. 7, a memory management unit (MMU) of a processor receives an effective address to be translated, STEP 700. The effective address is, for instance, a 64-bit address that may be received in an address translation request from the processor. As examples, the request may be from an instruction fetch unit of the processor, and therefore, the address to be translated is assumed to be for an instruction fetch, or the request may be from a load/store unit of the processor, and therefore, the address to be translated is assumed to be for a data access. In other embodiments, an indication in the request indicates whether the address translation is for an instruction fetch or a data access. The MMU translates the effective address to a virtual address, STEP 702. In one example, the translation from the effective address to the virtual address uses a segment lookaside buffer (SLB), as described further below. The MMU then translates the virtual address to a physical address, STEP 704. In one particular example, the translation from the virtual address to the physical address uses a hash page table, again as described further below. The MMU then uses the physical address to access the particular memory location, STEP 706.
Further details regarding translating from the effective address to the virtual address, by, for instance, the MMU are described with reference to FIGS. 8 and 9. Referring initially to FIG. 8, the MMU receives an effective address via, for instance, an address translation request sent from a particular unit (e.g., instruction fetch, load/store unit) of the CPU, STEP 800. Based on receiving the effective address, the MMU determines whether the address is for an instruction fetch or a data access. This can be determined, in one example, based on which unit (e.g., fetch unit or load/store unit of the CPU) the MMU received the address translation request or by an indicator associated with the request, as examples. For instance, if the address translation request came from the fetch unit, then it is assumed that the request is for an instruction fetch, and if it came from the load/store unit, it is assumed it is for a data access. Based on receiving the effective address, the MMU obtains an effective segment identifier from the effective address, STEP 802. The MMU then uses the effective segment identifier to search a segment lookaside buffer for a matching entry, STEP 804.
In particular, as shown in FIG. 9, in one embodiment, an effective address 900 is a 64-bit address including an effective segment identifier (ESID) 902, a page offset 904, and a byte offset 906. The effective segment identifier is extracted 910 from the effective address and used to search a segment lookaside buffer (SLB) 912 for a matching entry 914. A segment lookaside buffer (SLB) 912 is a cache of recently accessed segment ID entries. In one example, it is located in the MMU, but in other examples, it is located elsewhere. It specifies the mapping between effective segment IDs (ESIDs) and virtual segment IDs (VSIDs). The number of SLB entries (SLBE) in an SLB is implementation dependent, and in one example, includes at least 32 entries. In one example, segment lookaside buffer 912 includes a plurality of SLB entries 914, and each SLB entry 914 maps one ESID 902 to one VSID 916. In one example, SLBE 914 includes the following fields:
    Effective segment ID (ESID) 902 (bits 0-35); Entry valid indicator (V) 922 (bit 36) which indicates whether the entry is valid (V=1) or invalid (V=0); Segment size selector (B) 924 (bits 37-38), which has the following meaning, in one example: 0b00â256 Megabytes (MB) (s=28); 0b01â1 Terabyte (TB) (s=40); 0b10â256 TB (s=48); and 0b11âreserved; Virtual segment ID (VSID) 916 (bits 39-88); Supervisor (privileged) state storage key indicator (Ks) 928 (bit 89); Problem state storage key indicator (Kp) 930 (bit 90); No-execute segment if N=1 indicator (N) 932 (bit 91). Instructions cannot be executed from a No-execute (N=1) segment; Virtual page size selector bit 0 (L) 934 (bit 92); Class indicator (C) 936 (bit 93); The Class field of the SLBE is used in conjunction with, for instance, slbie (SLB invalidate entry) and slbia (SLB invalidate all) instructions. âClassâ refers to a grouping of SLB entries and implementation-specific lookaside information so that only entries in a certain group need be invalidated and others might be preserved. The Class value assigned to an implementation-specific lookaside entry derived from the SLB entry is to match the Class value of that SLB entry. The Class value assigned to an implementation-specific lookaside entry that is not derived from an SLB entry (such as real mode address âtranslationsâ) is 0. Virtual page size selector bits 1:2 (LP) 938 (bits 95-96); Segments may contain a mixture of page sizes. The L and LP bits specify the base virtual page size that the segment may contain. The SLBLâ¥LP encoding are those shown below, in one example. The base virtual page size (also referred to as the âbase page sizeâ) is the smallest virtual page size for the segment. The base virtual page size is 2b bytes. The actual virtual page size (also referred to as the âactual page sizeâ or âvirtual page sizeâ) is specified by PTELâ¥LP, where â¥ is a concatenation of the two values.   



 
 
 



 
 


 
Encoding
Page Size


 
 




 
0b000
â4 KB


 
0b101
64 KB


 
additional values1 
2b bytes, where b > 12 and b


 
 
may differ among encoding values


 
 


 
 1In one embodiment, the âadditional valuesâ are implementation-dependent, as are the corresponding base virtual page sizes. Any values that are not supported by a given implementation are reserved in that implementation, in at least one embodiment.




 


No Access (NOA) indicator 940 (bits 97:98), which NOA0=No Instruction (NOI); NOA1=No Data (NOD); 0b00âSLBE can be used for both instruction fetches and data accesses; 0b01âSLBE can only be used for instruction fetches; 0b10âSLBE can only be used for data accesses; and 0b11âreserved.



For each SLB entry, software is to ensure the following requirements are satisfied.
    Lâ¥LP contains a value supported by the implementation. The base virtual page size selected by the L and LP fields does not exceed the segment size selected by the B field. If s=40, the following bits of the SLB entry contain 0s.
         ESID24:35   VSID39:49   
   
The bits in the above two items are ignored by the processor.
In accordance with one aspect, the NOA field specifies for each SLB entry whether the SLB entry is to be used to translate an effective memory address to a virtual address for instruction fetch and data access (NOA=0b00, in one encoding of allowed accesses for a segment in accordance with one aspect), for data accesses but not instruction fetch (NOA=0b10, in one encoding of allowed accesses for a segment in accordance with one aspect), and for instruction fetch but not data access (NOA=0b01, in one encoding of allowed accesses for a segment in accordance with one aspect).
It is legal to have multiple effective to virtual segment id translations, as long as only one is selected to be performed based on the NOA bits. To accomplish this, software is to ensure that the SLB contains at most one entry that translates a given instruction effective address, and that if the SLB contains an entry that translates a given instruction effective address (NOA0=0), then no other entry can translate the same address for instruction fetches. In accordance with one aspect, when installing a new SLB entry for one or more access modes (e.g., instruction fetch), software is to ensure that any previously existing SLB translation entry of that effective address that may translate an address for such access mode has been invalidated. Likewise, software is to ensure that the SLB contains at most one entry that translates a given data effective address (NOA1=0), and that if the SLB contains an entry that translates a given data effective address, then any previously existing translation of that effective address for data accesses has been invalidated. An attempt to create an SLB entry that violates these requirements may cause a machine check. In accordance with one embodiment, a machine check is a high priority interrupt to a firmware, hypervisor or other supervisor component to indicate that system integrity constraints have been violated.
In accordance with one embodiment, it is permissible for software to replace the contents of a valid SLB entry without invalidating the translation specified by that entry provided the specified restrictions are followed.
When the hardware searches the SLB, all entries are tested for a match with the effective address (EA). For a match to exist, the following conditions are to be satisfied for indicated fields in the SLBE.
    V=1 (i.e., the valid bit is set for an entry) ESID0:63-s=EA0:63-s, where the value of s is specified by the B field in the SLBE being tested. The search is an instruction address search and NOI=0, or the search is a data address search and NOD=0.   
In particular, in one embodiment, an entry in the SLB is matching if the entry is valid, has an effective segment identifier matching the obtained effective segment identifier from the effective address, and the No Access (NOA) SLB field is set for the type of memory access being performed, e.g., for an instruction fetch or a data access. The NOA includes, for instance, two bits, in which a value of 01 indicates an address can be used to match addresses associated with instruction access only; 10 indicates an entry can be used to match addresses associated with data access only; and 00 indicates an entry can be used to match addresses associated with both instruction fetches and data accesses. If the NOA field is set for the requested access and the effective SID is the same as the obtained effective SID, then there is a match.
Returning to FIG. 8, a determination is made as to whether a matching entry in the SLB was found, INQUIRY 806. In particular, the matching logic is performed in conjunction with the NOA field of FIG. 9 indicating the types of accesses each particular SLBE may translate. If no matching entry was found, then there is indicated an SLB miss exception, which transfers control to a software handler for handling the exception, STEP 808. In at least one embodiment, the software handler manages the SLB as a cache and reloads a new SLB entry (SLBE) from a table of SLBEs maintained in memory. If, however, a matching entry is found, INQUIRY 806, then a determination is made as to whether multiple matching entries were found, INQUIRY 810. If there are multiple matches, a machine check may be taken, STEP 812, since there should not be multiple matches, or in another embodiment, one of the entries is selected and used.
However, if there is one match (or one is selected), a virtual segment identifier (VSID) 916 (FIG. 9) in the SLB entry is extracted 920 and used as part of the virtual address. The VSID is concatenated with page offset 904 and byte offset 906 from the effective address to create the virtual address. This virtual address is then returned, STEP 814 (FIG. 8).
As described above, for the SLB search, if no match is found, the search fails. If one match is found, the search succeeds. If more than one match is found, one of the matching entries may be used as if it were the only matching entry, or a machine check occurs. If the SLB search succeeds, the virtual address (VA) is formed from the EA and the matching SLB entry fields as follows: VA=VSID0:77-sâ¥EA64-s:63. The Virtual Page Number (VPN) is bits 0:77-p of the virtual address. The value of p is the actual virtual page size specified by the PTE used to translate the virtual address. If SLBEN=1, the N (noexecute) value used for the storage access is 1.
On an instruction fetch, if SLBEN=1, an Instruction Storage interrupt may occur without the page table being searched. If the SLB search fails, a segment fault occurs. This is an instruction segment exception or a data segment exception, depending on whether the effective address is for an instruction fetch or for a data access.
The virtual address created from translation of the effective address is then translated to a physical address (a.k.a., a real address) using, for instance, a hash page table. Further details regarding translation using a hash page table are described with reference to FIG. 10.
In particular, FIG. 10 illustrates one example of a hash page table (HPT) translation structure used by Power ISA. ESID portion 1006 of an effective address (EA) 1004 is used to locate an entry in SLB 1012. The entry includes a VSID field 1014. The value of VSID field 1014 and the page portion 1008 of EA 1004 are hashed 1030 to produce a hash value that is used to locate a page table entry (PTE) group 1052 in a hash page table (HPT) 1050. (In another embodiment, since the virtual address was previously created, the VSID and page portion may be extracted directly from the formed virtual address.) In at least one embodiment, the hash page table is located by a page table origin address provided by the processor. Page table entries 1053 of PTE group 1052 are searched to locate a corresponding PTE having a field matching a value of a most-significant-portion of the VSID. When a corresponding PTE is found, the address (e.g., real address) of the physical memory page in the PTE is used to access physical memory. In order to improve performance, once a PTE entry is found, the page portion 1008 of EA 1004 and the address of the physical memory page found in the PTE are stored in TLB 1054, such that further accesses to the same EA page will âhitâ in TLB 1054 and avoid the PTE search.
As described above, in one example, address translation is performed based on a particular attribute, such as, for instance, the type of access: instruction fetch or data access. To enable this, a mechanism is provided that includes a field in the SLB to prevent SLBEs from being used for instruction-side or data-side accesses. This field, as indicated above, is the No Access (NOA) field. The NOA is used to indicate that a particular SLBE associated with the NOA can be used for only instruction fetches, only data accesses, or for both instruction fetches and data accesses (e.g., when the code is not modified).
In accordance with one embodiment, the NOA field is separately specified for each segment in conjunction with an SLB entry, thereby allowing some effective address segments (memory regions of the input address) to be translated to a common segment address for instruction and data accesses (memory regions of the output address), and other segments (memory regions of the input address) to be translated to separate segment addresses for instruction and data accesses (memory regions of the output address), respectively, or to provide a translation for one type of access (e.g., instruction access), but not another type of access (e.g., data access) by loading an appropriate SLB entry for one type of access, but not another. While the description has been made with respect to the presence of a NO Access field, and to a specific encoding of a NO Access field in the SLB, it is understood that other fields, other encodings for such fields, or both, may be used to identify the types of permissible access for a translation.
As described herein, in accordance with one or more aspects, the separate instruction/data address translation technique is used to redirect address translation to a particular region of memory that includes modified code for instruction fetches and another region of memory that includes the unmodified code for data accesses, as shown in FIG. 11. In one or more examples, an SLB-based mechanism, as described above, may be used or other types of mechanisms, which are based, for instance on hierarchical or radix address translation structures. In such a hierarchical based mechanism, in one embodiment, an attribute indicator is provided in an entry of one of the structures in the hierarchy which directs which path is taken to translate an address. This path may select, e.g., instruction access only, data access only, or a shared access. One example of a hierarchical based mechanism is described in a co-filed, commonly assigned patent application, entitled âHierarchical Translation Structures Providing Separate Translations for Instruction Fetches and Data Accesses,â Michael K. Gschwind et al., (IBM Docket No.: POU920140011US1), which is hereby incorporated by reference herein in its entirety.
Referring to FIG. 11, in one example, patched application code 420 includes a modified portion, and that modified portion is stored in one or more memory regions 1100 of system memory 410. The unmodified portion continues to be in other memory regions 1102 of system memory 410. In particular, the other memory regions 1102 include the application prior to modification.
In this embodiment, an effective address 600 is used to access memory region 1100 or memory region 1102 depending on whether the address translation is for an instruction fetch 608 for a modified portion or a data access 610 for an unmodified portion. If, for instance, the translation is for an instruction fetch of a modified portion, then effective address 600 is translated to physical address 604 a, which points to memory region 1100 that includes modified code. However, if the address translation is for a data access, then effective address 600 is translated to physical address 604 b, which points to memory region 1102, which includes the unmodified, pre-existing or original code corresponding to the modified code.
In a further embodiment, with reference to FIG. 12, an effective address 1200 may use a shared translation 1202, in which a same memory region 1204 is used for an instruction fetch and a data access (since, for instance, that code portion has not been modified). In this example, effective address 1200 is translated to a physical address 1206, which points to memory region 1204.
The address translation capability described above is used, in one or more examples, in environments that provide dynamic code optimization. Dynamic code optimization (a.k.a., dynamic compilation and optimization) offers significant opportunities to improve the operation of computer systems. For instance, existing code can be modified to improve performance by re-optimizing hot regions, avoiding errors, correcting for errors, enhancing or changing security, providing additional features, etc. In accordance with one aspect, dynamic code optimization is used to exploit extended mode features for a selected application, while preventing other applications from exploiting the features. That is, the optimizer (e.g., dynamic code optimizer) sets one or more controls at an application level to enable the application to exploit extended mode features. As used herein, the setting of the one or more controls by the optimizer includes, for instance, the optimizer setting the controls, assuming the optimizer has such authority, and/or the optimizer directing a component that has authority, such as the operating system or hypervisor, to perform the actual setting, particularly when the optimizer lacks such authority.
As used herein, an optimizer refers to, for instance, a dynamic code optimizer, a compiler that performs optimization, such as a Just-In-Time (JIT) compiler, binary translators, as well as other components that provide optimization, as examples.
The extended mode features include, for instance, extended ISA features, in which DCO generated code executing with normal application level privilege is provided access to extended features, either those that are above a partition's or application's selected ISA level, or private implementation specific non-architected capabilities, including high performance modes, high performance instructions and/or high performance resources otherwise known or unavailable to the application, as just some examples.
An example of an above-level ISA is using instructions that are not available at the ISA level the application is executing (e.g., using vector-scalar (VSX) instructions when the ISA level is set to Power6, which did not offer VSX instructions).
An example of a high performance mode is an alternate mode where a different ISA is executed. Examples of such ISAs may be a VLIW ISA (Very Long Instruction Words offer enhanced software control of parallelism by allowing a compiler to specify a plurality of instructions to be performed in parallel) or a Wide-Word Power ISA (WW-Power) where each Power instruction has more than 32b, to give access to additional functions, wider displacements, and so forth.
Examples of non-architected high performance instructions are additional move instructions to move data directly between register files of different types, a branch to TAR (target address register) instruction, or additional prefetch control instructions, as examples.
An example of high performance resources are extensions to provide additional registers, either as part of the general purpose registers, floating point registers or vector scalar register sets, or additional special purpose registers, such as a TAR register.
The above-described types of enhancements are collectively referred to herein as extended mode features, which are features known to the optimizer, but unknown or unavailable to the application, unless enabled by the optimizer. Again, as a few examples, these extended mode features include, for instance, extended ISA features (e.g., features at a higher level than the level at which the application is executing); alternate ISA modes; non-architected high performance instructions; high performance resources; etc. Other features may also be considered extended mode features, as described herein.
In accordance with one or more aspects, the optimizer sets one or more controls, referred to, e.g., as extended mode controls, to selectively provide extended mode features for an application. As described herein, the extended mode controls may include one or more of: one or more extended mode enable facilities, and/or one or more extended mode control authorization facilities, each of which is described below.
Examples of controls that may be used to provide extended mode features are described with reference to FIGS. 13A-13F. For instance, with reference to FIG. 13A, one or more controls are provided in a control register 1300. Control register 1300 includes selected information, including, for instance, one or more extended mode controls 1302, that are used to indicate whether extended mode features are available for an application. Examples of such a control register include a machine state register (MSR) or a program status word (PSW).
Referring to FIG. 13B, in one example, a machine state register 1310 includes selected information, including one or more extended mode controls 1312. In one particular embodiment, the machine state register (MSR) is a 64-bit register that defines the state of a thread, and the selected information includes, for instance, the following definitions:
    Bit Description 0 Sixty-Four Bit Mode (SF)
         0 The thread is in 32-bit mode 1 The thread is in 64-bit mode 
 1:2 Reserved 3 Hypervisor State (HV)
         0 The thread is not in hypervisor state 1 If MSRPR=0 the thread is in hypervisor state; otherwise the thread is not in hypervisor state. 
 4 Extended Mode Enable Facility
         0 Extended mode is disabledâCode, e.g., code generated by the optimizer, cannot use extended mode facility. 1 Extended mode is enabledâCode, e.g., code generated by the optimizer, is authorized to use extended mode facility. 
 5 Split Little Endian (SLE)
         0 Instruction and data storage accesses for the thread are the same and use the value specified by MSRLE. 1 Instruction and data storage accesses for the thread are opposite. Instruction storage accesses use the value specified by MSRLE. Data storage accesses use the value specified by MSRLE. 
 6 Extended Mode Control Authorization Facility
         0 Application (user mode) is not allowed to use extended mode control features, and extended mode enable facility cannot be set by user mode code. 1 Application (user mode) is allowed to use extended mode control features, and extended mode enable facility can be set by user mode code. 
 7:28 Reserved 29:30 Transaction State (TS) [Category: Transactional Memory]
         00 Non-transactional 01 Suspended 10 Transactional 11 Reserved 
 31 Transactional Memory Availableâ¢ [Category: Transactional Memory]
         0 The thread cannot execute any transactional memory instructions or access any transactional memory registers. 1 The thread can execute transactional memory instructions and access transactional memory registers unless the transactional memory facility has been made unavailable by some other register. 
 32:37 Reserved 38 Vector Available (VEC) [Category: Vector]
         0 The thread cannot execute any vector instructions, including vector loads, stores, and moves. 1 The thread can execute vector instructions unless they have been made unavailable by some other register. 
 39 Reserved 40 VSX Available (VSX)
         0 The thread cannot execute any VSX instructions, including VSX loads, stores, and moves. 1 The thread can execute VSX instructions unless they have been made unavailable by some other register. 
 41:47 Reserved 48 External Interrupt Enable (EE)
         0 External, decrementer, performance monitor <S>, and privileged doorbell interrupts <S.PC.> are disabled. 1 External, decrementer, performance monitor <S>, and privileged doorbell interrupts <S.PC.> are enabled. 
 49 Problem State (PR)
         0 The thread is in privileged state. 1 The thread is in problem state. 
 50 Floating Point Available (FP) [Category: Floating Point]
         0 The thread cannot execute any floating point instructions, including floating point loads, stores and moves. 1 The thread can execute floating point instructions unless they have been made unavailable by some other register. 
 51 Machine Check Interrupt Enable (ME)
         0 Machine check interrupts are disabled. 1 Machine check interrupts are enabled. 
 52 Floating Point Exception Mode 0 (FE0) [Category: Floating Point] See below. 53 Single Step Trace Enable (SE) [Category: Trace]
         0 The thread executes instructions normally. 1 The thread generates a single step type trace interrupt after successfully completing the execution of the next instruction, unless that instruction is a defined instruction which is not traced. Successful completion means that the instruction caused no other interrupt and, if the processor is in the transactional state <TM>, is not one of the instructions that is forbidden in transactional state. 
 54 Branch Trace Enable (BE) [Category: Trace]
         0 The thread executes branch instructions normally. 1 The thread generates a branch type trace interrupt after completing the execution of a branch instruction, whether or not the branch is taken. Branch tracing need not be supported on all implementations that support the trace category. If the function is not implemented, this bit is treated as reserved. 
 55 Floating Point Exception Mode 1 (FE1) [Category: Floating Point]
         The floating point exception mode bits FE0 and FE1 are interpreted as shown below. FE0 FE1 Mode 0 0 Ignore Exceptions 0 1 Imprecise Non-recoverable 1 0 Imprecise Recoverable 1 1 Precise 
 56:57 Reserved 58 Instruction Relocate (IR)
         0 Instruction address translation is disabled. 1 Instruction address translation is enabled. 
 59 Data Relocate (DR)
         0 Data address translation is disabled. Effective Address Overflow (EAO) does not occur. 1 Data address translation is enabled. EAO causes a data storage interrupt. 
 60 Reserved 61 Performance Monitor Mark (PMM) [Category: Server]
         For use in indicating whether certain performance counters are to count events for selected processes. 
 62 Recoverable Interrupt (RI)
         0 Interrupt is not recoverable. 1 Interrupt is recoverable. 
 63 Little-Endian Mode (LE)
         0 Instruction and data storage accesses for the thread are in Big Endian mode when MSRSLE=0. When MSRSLE=1, instruction storage accesses are in Big Endian mode and data storage accesses are in Little Endian mode. 1 Instruction and data storage accesses for the thread are in Little Endian mode when MSRSLE=0. When MSRSLE=1, instruction storage accesses are in Little Endian mode and data storage accesses are in Big Endian mode. 
   
In accordance with one embodiment, extended mode features (also referred to as high speed mode) are enabled by an extended mode enable facility, as shown in one example as being assigned to a bit position 4 of a machine state register. When this bit is set to 1, it enables extended mode features, such as, for example, including one or more of the following:
(1) Instructions available on a specific hardware implementation but disabled by way of the setting of a virtual architecture level lower than the architecture level implemented by the present implementation, e.g., using a processor compatibility register (PCR) in accordance with the Power ISA (Instruction Set Architecture), or a Virtual Architecture Level (VAL) setting in accordance with the System z ISA;
(2) Instructions corresponding to implementation specific extensions not specified by any corresponding ISA level, e.g., instructions generally reserved for use by the microcode;
(3) Instructions that are limited to execution by microcode, millicode, firmware, or privileged software;
(4) Instructions that are otherwise part of separately controlled subsets, e.g., including, but not limited to, those of the FPU (floating point), VMX (vector media extensions), and VSX (vector scalar) facilities in accordance with the Power ISA, or extended facilities of the Power ISA;
(5) An ISA separate and/or distinct from the published ISA, such as a VLIW or WW_Power ISA, and so forth.
In at least one other embodiment, a plurality of extended mode enable facilities (e.g., a plurality of bits) are provided, and each of the plurality of extended mode enable facilities offers individual access to one or more extended features including, but not limited, to the ones described herein.
In accordance with one embodiment, a separate extended mode control authorization facility is provided, as shown in accordance with one embodiment as being assigned to a bit position 6 of a machine state register. In accordance with one embodiment, an extended mode control authorization facility is provided to control an application's ability to modify the extended mode enable facility and thereby gain access to extended mode features. In accordance with at least one aspect, only some applications are enabled with access to the extended mode enable facility. In one embodiment, these applications correspond to one or more of those being used in conjunction with dynamic code optimization, binary translation, and Just-in-Time compilation, in accordance with one or more aspects.
In at least one embodiment, the extended mode control authorization facility also gives applications the ability to control access to enable one or more restricted and separately controlled modes, e.g., those controlled by MSR[FP], MSR[VEC] and MSR[VSX]. In at least one embodiment, when the extended mode control authorization facility is enabled, user-level applications are also authorized to enable one or more of these modes.
In addition to, or instead of, including one or more extended mode controls (e.g., one or more extended mode enable facilities, and/or one or more extended mode control authorization facilities) in a control register, such as a machine state register, a program status word, or other type of control register, extended mode controls can be included in various address translation structures, as shown in FIG. 13C. For instance, a particular address translation structure includes a plurality of entries 1320, and each entry 1320 includes various information to be used in translating an address. Further, in accordance with one aspect, the information may also include one or more extended mode controls 1322 to indicate whether application code corresponding to the memory region being translated can use extended mode features. For instance, extended mode controls 1322 may indicate, e.g., whether application code corresponding to the memory region being translated has authority to use extended mode features (e.g., extended mode control authorization facility), and/or whether the extended mode is enabled for application code corresponding to the memory region being translated (e.g., extended mode enable facility).
In one embodiment, one or more of the controls correspond to application code with user privilege level, but not to code with supervisor privilege level. In one embodiment, one or more of the controls correspond to partition-level code (i.e., code with user and operating system privilege level), but not to code with hypervisor privilege level. In yet another embodiment, one or more of the controls correspond to code with user, operating system and hypervisor privilege level, but not to code of yet another fourth privilege level, and so forth.
One particular address translation structure is a page table, and with reference to FIG. 13D, a page table entry 1330 is described, which includes selected information including one or more extended mode controls 1332. In one particular example, the selected information includes address information (e.g., a page frame real address) used to create a physical address, as well as controls to control execution of the page associated with the physical address. These controls depend, for instance, on the system architecture; however, in accordance with one aspect, one or more of the controls include one or more of extended mode controls 1332. As described above, one or more extended mode controls 1332 are used to indicate whether application code corresponding to the memory region being translated can use extended mode features. For instance, extended mode controls 1322 may indicate, e.g., whether application code corresponding to the memory region being translated has authority to use extended mode features (e.g., extended mode control authorization facility), and/or whether the extended mode is enabled for application code corresponding to the memory region being translated (e.g., extended mode enable facility).
In further examples, one or more extended mode controls may be included in other address translation structures, such as a segment table entry (STE), region table entries (RTE), and/or other address translation entries that are used in translation, as well as to control memory access.
Additionally, in a further example, one or more extended mode controls may be included in a storage key, an example of which is depicted in FIG. 13E. A storage key 1340 is associated with each 4K byte of real storage, and is used to control access. In one example, it includes selected information, such as, e.g., access control bits, a fetch protection bit, a reference bit and a change bit, as well as an extended mode control 1342. Again, if the extended mode enable control is set to 0, use of external mode control features is disabled, and if set to 1, use of external mode control features is enabled. Further, extended mode controls 1342 may also include an extended mode control authorization facility.
In a further embodiment, instead of enabling/disabling extended mode features in totality, there may be separate controls for individual features of the extended mode features. In this case, each control register, address translation entry or storage key would have multiple extended mode controls, one for each feature. For instance, there may be a plurality of extended mode enable facilities, one for each feature such that use of a particular feature may be enabled/disabled; and/or there may be a plurality of extended mode control authorization facilities, one for each feature.
However, in one embodiment, to optimize the number of bits used in an address translation structure entry (e.g., a PTE, STE, RTE, SLBe etc.) or a storage key, as examples, but still enable multiple independent controls, a single bit is used to indicate whether a specific memory region (e.g., page, segment, region, etc.) is enabled to use the extended mode features, and then, a secondary set of bits is stored in, for instance, a control register (e.g., MSR, PSW) or a special purpose register to determine which of a plurality of features is enabled by the DCO component. Similarly, a single bit may be stored in an address translation structure or storage key for the extended mode control authorization facility, and then a secondary set of bits may be stored in a control register to determine which of a plurality of features is authorized.
For instance, as shown in FIG. 13F, a page table entry 1350 includes an indicator (e.g., bit) 1352 that, if set to one, indicates, for instance, extended mode features are enabled for the application, but the particular features 1354 that are enabled to be used are indicated, for instance, in a control register, such as machine state register 1360. Indicator 1352 may similarly be used for the extended mode control authorization facility. In a further embodiment, control 1352 may include two bits: one for the extended mode enable facility, and another for the extended mode control facility, and then, the control register includes a secondary set of bits for each of those.
The control register indicating the selected extended mode features is maintained, for instance, at the thread level, and context switches by the operating system, give the DCO component separate control over the features enabled for each application process. In other implementations, the extended mode controls are shared by all threads within a process, or by all processes within a partition, or by all threads within a core, and so forth, offering different levels of granularity.
In yet another embodiment, the extended mode control is implicitly provided in an entry of a segment lookaside buffer (SLBe). For instance, the extended mode control is shared with the No-data (NOA=D) bit of the SLBe. That is, in one example, when a page is not available for data accesses in a mappingâcorresponding, e.g., to hidden code to ensure, e.g., correct self referential executionâadditional functions that are only to be made available to code generated by DCO are provided to code executing from such pages. In one aspect, the extended mode control (e.g., single bit) enables a plurality of selections stored in an MSR, PSW, CR or SPR, as per above. In another aspect, the No-data access bit indicates whether or not extended modes are available with no further selection.
Embodiments of logic to perform optimization, and optionally, use the extended mode features, are described with reference to FIGS. 14A-15. In particular, FIG. 14A depicts one embodiment of generating optimized code without use of the extended mode control(s), and FIG. 14B depicts one embodiment of generating optimized code using the extended mode control(s). Further, FIG. 15 depicts one embodiment of executing the optimized code having the extended mode control(s).
Referring initially to FIG. 14A, a dynamic optimizer, such as a dynamic code optimizer, is initiated within a processor (e.g., by the operating system, an application, on its own, etc.), STEP 1400. The optimizer identifies code to be patched, STEP 1402. For instance, the dynamic code optimizer identifies hot regions or areas in which the code may be optimized. Based on identifying the code to be modified, new code is generated, STEP 1404. In one embodiment, this includes copying the portion of the code to be modified, and then, modifying that copied portion, STEP 1404. The portion is copied, instead of copying the entire application. That is, only that portion to be modified is copied and stored in separate memory regions. The modifying may include any number of known optimization techniques, including, but not limited to, rollout, inline optimization, etc.
Subsequent to generating the new modified code, that modified code is written to system memory and stored in memory locations that are different from the memory locations of the application, STEP 1406. Further, page mappings are updated to make the modified code available, STEP 1408. This includes, for instance, indicating to the one or more components of the computing environment, such as the operating system or the MMU, as examples, of where the modified code is located, and the type of access permitted for that code. For instance, the optimizer indicates that the modified code is located at physical memory regions x to x+n and should be made available at effective addresses y to y+n, and the type of access is instruction fetch only which should be used in conjunction with an existing mapping for data accesses, either by changing a current existing I/D translation memory region into a separate I/D translation memory region in supplanting the pre-existing shared translation for addresses y to y+n by data translation to the previously used physical memory but limited to data only accesses in conjunction with instruction accesses for y to y+n being directed to physical addresses x to x+n. In another aspect of at least one embodiment, an instruction only translation is added to a pre-existing data only translation. In one example, the optimizer is provided an interface to facilitate providing this information.
In one embodiment, based on receiving the mapping information, the processor, such as the MMU, creates SLBEs to be used to translate to the new pages on a control of system software extended to initialize separate SLBE entries for instruction and data accesses, in accordance with one aspect. For instance, the current SLBE that points to the code prior to being modified is copied and the VSID is updated to reflect the location of the new pages and the NOA is set to instruction access only. Further, the NOA and the SLBE pointing to the unmodified code is updated from shared to data access only. In particular, in one example, a new SLBE is created for instruction-only access and translated to a new virtual address. Pages in the new virtual address range are initialized to the new supplied memory region. Pages within the new memory region that are not initialized to a new instruction-only page may be initialized to point to the unmodified code pages when only a portion of a memory region is modified. In one embodiment, these pages are initialized when a new virtual address range in conjunction with an instruction only SLBE is created. In another embodiment, they are initialized in a deferred manner such that when an access is performed, a page fault is indicated and initialization occurs in conjunction with servicing the page fault.
Referring to FIG. 14B, in one example, optimization further takes into account whether one or more extended mode controls are provided. Referring to FIG. 14B, the optimizer begins generating the optimized code, STEP 1450, and a determination is made as to whether the code is to benefit from extended mode features, INQUIRY 1452. If not, then compliant code (i.e., code compliant with the currently active architecture level) is generated as described above, STEP 1454. However, if the determination is made that code is to benefit from extended mode features, then the code that is generated uses the one or more additional features that are available, based on selection by the optimizer, STEP 1456. This includes, for instance, using an instruction that replaces multiple instructions, using a higher architectural mode, or other types of enhancements. Further, one or more extended mode controls are set by the optimizer for the application, STEP 1458. For instance, the optimizer injects code to enable extended mode features prior to use, as described with reference to FIG. 15, STEP 1460, or optionally, performs steps to indicate the application or select portions of the application (such as only DCO generated code) may use and/or is authorized to use, extended mode features, such as authorize the application to use the extended mode features (e.g., set one or more control indicators in PTE, requests that the extended mode control authorization facility be turned on, etc.), STEP 1462.
One example of injecting code to enable use of the extended mode features is described with reference to FIG. 15. FIG. 15 depicts one example flow of using a control register to enable extended mode features.
Initially, the unmodified application code is executing, STEP 1500, and then a branch is performed to the optimized application code, STEP 1502. In one example, this includes executing an instruction fetch using an SLBE for instruction access only. At the new code, the optimizer sets the extended mode control (e.g., extended mode enable facility) in a control register using, for instance, a series of instructions, STEP 1504. For instance, a move from machine state register (mfmsr) instruction is used to take the contents of the MSR register and place the MSR contents in a register, rx, (rx being an exemplary register wherein x can take any register number, e.g., from 0 to 31 depending on the registers provided in an architecture that may be used in conjunction with an architecture). Then, an OR immediate instruction is performed to set the value to indicate extended mode is enabled. Then, a move to machine state register (mtmsr) instruction is performed to move that value back to the machine state register. Optimized coding is then performed in the new mode, STEP 1506, i.e., using one or more extended mode features, as deemed appropriate by the optimizer.
When processing is complete, then the extended mode control (e.g., extended mode enable facility) is set to disabled by once again using a number of instructions, STEP 1508. For instance, the mfmsr is executed and the value in the MSR is moved to a register, rx, an AND immediate is performed to set the extended mode control to disabled, and that value is moved to the MSR using, e.g., the mtmsr instruction. Then, processing returns to the unoptimized original application code, STEP 1510. In one example, this includes using a branch to a special purpose register, such as a target address register (TAR). To perform this branch, the return address is loaded in a register rx (rx being an exemplary register wherein x can take any register number, e.g., from 0 to 31 depending on the registers provided in an architecture that may be used in conjunction with an architecture, and the value âreturn addressâ being represented either as an immediately loaded value, or a value loaded from memory as an operand using one from a variety of possible addressing modes commonly used by load instructions in an architecture), a move to TAR instruction is executed to copy the value in rx to the TAR, and a branch conditional instruction is executed to branch to the address in the TAR. Processing then continues at the unmodified application code, STEP 1512.
In accordance to one embodiment, the TAR register is a target address register that may be used in conjunction with branch instructions as a register-specified target address. In accordance with at least one embodiment, the use of the TAR register is restricted to DCO functions and other system functions and not available to unoptimized application code. In one embodiment, the TAR register represents an exemplary extended mode function that is used by a DCO component to generate optimized code for branching to unoptimized code.
In one embodiment, for STEPs 1504 and 1508, instead of using a plurality of instructions, a new instruction may be created, referred to, for instance, as MTEM (Move to Extended Mode), that sets/resets an extended mode control in a control register.
Further, in the example described above, one extended mode control is enabled allowing the application access to the extended mode features. However, in other embodiments, separate controls in the control register and/or elsewhere may be enabled/disabled for individual features. Other variations are also possible.
One example of a move from machine state register instruction is described with reference to FIG. 16A. In one example format, a move from machine state register instruction 1600 includes a plurality of opcode fields 1602 a, 1602 b indicating a move from machine state register operation, and a register field (RT) 1604. The contents of the MSR are placed in the register designated in the RT field 1604.
Further, one example of a move to machine state register instruction is described with reference to FIG. 16B. In one example format, a move from machine state register instruction 1650 includes a plurality of opcode fields 1652 a, 1652 b indicating a move to machine state register operation, a register field (RS) 1654, and an L field 1656.
In operation, if L=0 then

MSR48â(RS)48|(RS)49 

MSR58â(RS)58|(RS)49 

MSR59â(RS)59|(RS)49 

MSR32:47 49:50 52:57 60:62â(RS)32:47 49:50 52:57 60:62 

else

MSR48 62â(RS)48 62 

The MSR is set based on the contents of register RS and of the L field.
    L=0:
         The result of ORing bits 48 and 49 of register RS is placed into MSR48. The result of ORing bits 58 and 49 of register RS is placed into MSR58. The result of ORing bits 59 and 49 of register RS is placed into MSR59. Bits 32:47, 49:50, 52:57, and 60:62 of register RS are placed into the corresponding bits of the MSR. 
 L=1:
         Bits 48 and 62 of register RS are placed into the corresponding bits of the MSR. The remaining bits of the MSR are unchanged. 
 If L=0 this instruction is context synchronizing. If L=1 this instruction is execution synchronizing.   
Described above is a facility in which an optimizer may provide an application with extended mode features (also referred to as enhanced or special modes.) In one aspect, a user level application starts with, e.g., MSR bits enabling such extended mode features as disabled. The extended mode control bit (or bits) are not enabled to be set by an application level program, and no supervisor software interface is provided to normal applications to enable these settings. Thus, an application attempting to use such instructions will experience an error corresponding to the execution of an illegal instruction. Then, when the dynamic optimizer generates and injects optimized code, the dynamic optimizer enables the additional features for an application/address space, either by way of special permissions given by hardware to a DCO component (e.g., a separate execution privilege level), or by an interface between the DCO component and supervisor software to enable these MSR controls and keep them set for the present application. Once this bit, or a plurality of bits to control separately different capabilities and modes, are set, the functions are available to the application, and maintained set for the application during task switches performed by the operating system, etc.
Additional MSR bits may also be provided to enable operational modes, such as FPU, VEC or VSX, while these are ostensibly disabled for a specific application.
In one embodiment, the extended mode control bit, or an additional bit also controls a branch and switch mode instruction which may be provided by the hardware to enable a DCO component to transfer control from original code to an optimized dynamically generated version of the code having been compiled to optimize a hot spot and take advantage of such high performance mode instructions or resourcesâbranch and switch mode to Xâand a second branch instructionâbranch and switch mode from X, where X corresponds to a specific of one or more modes including normal mode, and at least one extended mode.
In another aspect, as described herein, enablement bits are not associated with an executing application by way of MSR bits, but are set at an application level. In conjunction with one embodiment, a page table entry contains one or more extended mode control bits associated to a page. When the DCO component generates optimized code and installs a new page with such code, it causes the permissions of the page table entry to be set to enable additional instructions, resources, or ISA levels exceeding the ISA level set by the processor compatibility register PCR in accordance with the specification of the Power ISA v2.07, included herein by reference, or the VAL specification in accordance with the System z/Architecture, included herein by reference, or any other software control for setting software-controlled architecture levels in accordance with an architecture. In another aspect of page table entry associated extended mode bits, the mode bit selects an alternate execution mode, such as a VLIW (Very Long Instruction Word) or WW-Power instruction set encoding.
In one aspect, a processor includes an instruction state context (ISC), such that the ISC indicates an architecture level of an instruction set architecture (ISA_being used). Thus, an application program may specify an ISA to be used for a portion of the program currently being executed, by specifying the ISC.
Referring to FIG. 17, in one example, a computer program product 1700 includes, for instance, one or more non-transitory computer readable storage media 1702 to store computer readable program code means, logic and/or instructions 1704 thereon to provide and facilitate one or more embodiments.
The present invention may be a system, a method, and/or a computer program product. The computer program product may include a computer readable storage medium (or media) having computer readable program instructions thereon for causing a processor to carry out aspects of the present invention.
The computer readable storage medium can be a tangible device that can retain and store instructions for use by an instruction execution device. The computer readable storage medium may be, for example, but is not limited to, an electronic storage device, a magnetic storage device, an optical storage device, an electromagnetic storage device, a semiconductor storage device, or any suitable combination of the foregoing. A non-exhaustive list of more specific examples of the computer readable storage medium includes the following: a portable computer diskette, a hard disk, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM or Flash memory), a static random access memory (SRAM), a portable compact disc read-only memory (CD-ROM), a digital versatile disk (DVD), a memory stick, a floppy disk, a mechanically encoded device such as punch-cards or raised structures in a groove having instructions recorded thereon, and any suitable combination of the foregoing. A computer readable storage medium, as used herein, is not to be construed as being transitory signals per se, such as radio waves or other freely propagating electromagnetic waves, electromagnetic waves propagating through a waveguide or other transmission media (e.g., light pulses passing through a fiber-optic cable), or electrical signals transmitted through a wire.
Computer readable program instructions described herein can be downloaded to respective computing/processing devices from a computer readable storage medium or to an external computer or external storage device via a network, for example, the Internet, a local area network, a wide area network and/or a wireless network. The network may comprise copper transmission cables, optical transmission fibers, wireless transmission, routers, firewalls, switches, gateway computers and/or edge servers. A network adapter card or network interface in each computing/processing device receives computer readable program instructions from the network and forwards the computer readable program instructions for storage in a computer readable storage medium within the respective computing/processing device.
Computer readable program instructions for carrying out operations of the present invention may be assembler instructions, instruction-set-architecture (ISA) instructions, machine instructions, machine dependent instructions, microcode, firmware instructions, state-setting data, or either source code or object code written in any combination of one or more programming languages, including an object oriented programming language such as Smalltalk, C++ or the like, and conventional procedural programming languages, such as the âCâ programming language or similar programming languages. The computer readable program instructions may execute entirely on the user's computer, partly on the user's computer, as a stand-alone software package, partly on the user's computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario, the remote computer may be connected to the user's computer through any type of network, including a local area network (LAN) or a wide area network (WAN), or the connection may be made to an external computer (for example, through the Internet using an Internet Service Provider). In some embodiments, electronic circuitry including, for example, programmable logic circuitry, field-programmable gate arrays (FPGA), or programmable logic arrays (PLA) may execute the computer readable program instructions by utilizing state information of the computer readable program instructions to personalize the electronic circuitry, in order to perform aspects of the present invention.
Aspects of the present invention are described herein with reference to flowchart illustrations and/or block diagrams of methods, apparatus (systems), and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and/or block diagrams, and combinations of blocks in the flowchart illustrations and/or block diagrams, can be implemented by computer readable program instructions.
These computer readable program instructions may be provided to a processor of a general purpose computer, special purpose computer, or other programmable data processing apparatus to produce a machine, such that the instructions, which execute via the processor of the computer or other programmable data processing apparatus, create means for implementing the functions/acts specified in the flowchart and/or block diagram block or blocks. These computer readable program instructions may also be stored in a computer readable storage medium that can direct a computer, a programmable data processing apparatus, and/or other devices to function in a particular manner, such that the computer readable storage medium having instructions stored therein comprises an article of manufacture including instructions which implement aspects of the function/act specified in the flowchart and/or block diagram block or blocks.
The computer readable program instructions may also be loaded onto a computer, other programmable data processing apparatus, or other device to cause a series of operational steps to be performed on the computer, other programmable apparatus or other device to produce a computer implemented process, such that the instructions which execute on the computer, other programmable apparatus, or other device implement the functions/acts specified in the flowchart and/or block diagram block or blocks.
The flowchart and block diagrams in the Figures illustrate the architecture, functionality, and operation of possible implementations of systems, methods, and computer program products according to various embodiments of the present invention. In this regard, each block in the flowchart or block diagrams may represent a module, segment, or portion of instructions, which comprises one or more executable instructions for implementing the specified logical function(s). In some alternative implementations, the functions noted in the block may occur out of the order noted in the figures. For example, two blocks shown in succession may, in fact, be executed substantially concurrently, or the blocks may sometimes be executed in the reverse order, depending upon the functionality involved. It will also be noted that each block of the block diagrams and/or flowchart illustration, and combinations of blocks in the block diagrams and/or flowchart illustration, can be implemented by special purpose hardware-based systems that perform the specified functions or acts or carry out combinations of special purpose hardware and computer instructions.
In addition to the above, one or more aspects may be provided, offered, deployed, managed, serviced, etc. by a service provider who offers management of customer environments. For instance, the service provider can create, maintain, support, etc. computer code and/or a computer infrastructure that performs one or more aspects for one or more customers. In return, the service provider may receive payment from the customer under a subscription and/or fee agreement, as examples. Additionally or alternatively, the service provider may receive payment from the sale of advertising content to one or more third parties.
In one aspect, an application may be deployed for performing one or more embodiments. As one example, the deploying of an application comprises providing computer infrastructure operable to perform one or more embodiments.
As a further aspect, a computing infrastructure may be deployed comprising integrating computer readable code into a computing system, in which the code in combination with the computing system is capable of performing one or more embodiments.
As yet a further aspect, a process for integrating computing infrastructure comprising integrating computer readable code into a computer system may be provided. The computer system comprises a computer readable medium, in which the computer medium comprises one or more embodiments. The code in combination with the computer system is capable of performing one or more embodiments.
Although various embodiments are described above, these are only examples. For example, computing environments of other architectures can be used to incorporate and use one or more embodiments. Further, different instructions, instruction formats, instruction fields and/or instruction values may be used. Yet further, other types of address translation may benefit from one or more aspects. Many variations are possible.
Further, other types of computing environments can benefit and be used. As an example, a data processing system suitable for storing and/or executing program code is usable that includes at least two processors coupled directly or indirectly to memory elements through a system bus. The memory elements include, for instance, local memory employed during actual execution of the program code, bulk storage, and cache memory which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.
Input/Output or I/O devices (including, but not limited to, keyboards, displays, pointing devices, DASD, tape, CDs, DVDs, thumb drives and other memory media, etc.) can be coupled to the system either directly or through intervening I/O controllers. Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems, cable modems, and Ethernet cards are just a few of the available types of network adapters.
Referring to FIG. 18, representative components of a Host Computer system 5000 to implement one or more embodiments are portrayed. The representative host computer 5000 comprises one or more CPUs 5001 in communication with computer memory (i.e., central storage) 5002, as well as I/O interfaces to storage media devices 5011 and networks 5010 for communicating with other computers or SANs and the like. The CPU 5001 is compliant with an architecture having an architected instruction set and architected functionality. The CPU 5001 may have access register translation (ART) 5012, which includes an ART lookaside buffer (ALB) 5013, for selecting an address space to be used by dynamic address translation (DAT) 5003 for transforming program addresses (virtual addresses) into real addresses of memory. A DAT typically includes a translation lookaside buffer (TLB) 5007 for caching translations so that later accesses to the block of computer memory 5002 do not require the delay of address translation. Typically, a cache 5009 is employed between computer memory 5002 and the processor 5001. The cache 5009 may be hierarchical having a large cache available to more than one CPU and smaller, faster (lower level) caches between the large cache and each CPU. In some implementations, the lower level caches are split to provide separate low level caches for instruction fetching and data accesses.
In one embodiment, an instruction is fetched from memory 5002 by an instruction fetch unit 5004 via a cache 5009. The instruction is decoded in an instruction decode unit 5006 and dispatched (with other instructions in some embodiments) to instruction execution unit or units 5008. Typically several execution units 5008 are employed, for example an arithmetic execution unit, a floating point execution unit and a branch instruction execution unit. The instruction is executed by the execution unit, accessing operands from instruction specified registers or memory as needed. If an operand is to be accessed (loaded or stored) from memory 5002, a load/store unit 5005 typically handles the access under control of the instruction being executed. Instructions may be executed in hardware circuits or in internal microcode (firmware) or by a combination of both.
As noted, a computer system includes information in local (or main) storage, as well as addressing, protection, and reference and change recording. Some aspects of addressing include the format of addresses, the concept of address spaces, the various types of addresses, and the manner in which one type of address is translated to another type of address. Some of main storage includes permanently assigned storage locations. Main storage provides the system with directly addressable fast-access storage of data. Both data and programs are to be loaded into main storage (from input devices) before they can be processed.
Main storage may include one or more smaller, faster-access buffer storages, sometimes called caches. A cache is typically physically associated with a CPU or an I/O processor. The effects, except on performance, of the physical construction and use of distinct storage media are generally not observable by the program.
Separate caches may be maintained for instructions and for data operands. Information within a cache is maintained in contiguous bytes on an integral boundary called a cache block or cache line (or line, for short). A model may provide an EXTRACT CACHE ATTRIBUTE instruction which returns the size of a cache line in bytes. In another embodiment, this information may be obtained from firmware, e.g., in accordance with interfaces specified by the Power Architecture Platform Reference specification. A model may also provide one or more of data cache block touch (dcbt), PREFETCH DATA and PREFETCH DATA RELATIVE LONG instructions which effects the prefetching of storage into the data or instruction cache or the releasing of data from the cache.
Storage is viewed as a long horizontal string of bits. For most operations, accesses to storage proceed in a left-to-right sequence. The string of bits is subdivided into units of eight bits. An eight-bit unit is called a byte, which is the basic building block of all information formats. Each byte location in storage is identified by a unique nonnegative integer, which is the address of that byte location or, simply, the byte address. Adjacent byte locations have consecutive addresses, starting with 0 on the left and proceeding in a left-to-right sequence. Addresses are unsigned binary integers and are 24, 31, or 64 bits.
Information is transmitted between storage and a CPU or a channel subsystem one byte, or a group of bytes, at a time. Unless otherwise specified, in, for instance, the POWER ISA and z/Architecture, a group of bytes in storage is addressed by the leftmost byte of the group. The number of bytes in the group is either implied or explicitly specified by the operation to be performed. When used in a CPU operation, a group of bytes is called a field. Within each group of bytes, in, for instance, the POWER ISA and z/Architecture, bits are numbered in a left-to-right sequence. In the POWER ISA and z/Architecture, the leftmost bits are sometimes referred to as the âhigh-orderâ bits and the rightmost bits as the âlow-orderâ bits. Bit numbers are not storage addresses, however. Only bytes can be addressed. To operate on individual bits of a byte in storage, the entire byte is accessed. The bits in a byte are numbered 0 through 7, from left to right (in, e.g., the z/Architecture). The bits in an address may be numbered 8-31 or 40-63 for 24-bit addresses, or 1-31 or 33-63 for 31-bit addresses; they are numbered 0-63 for 64-bit addresses. In one example, bits 8-31 and 1-31 apply to addresses that are in a location (e.g., register) that is 32 bits wide, whereas bits 40-63 and 33-63 apply to addresses that are in a 64-bit wide location. Within any other fixed-length format of multiple bytes, the bits making up the format are consecutively numbered starting from 0. For purposes of error detection, and in preferably for correction, one or more check bits may be transmitted with each byte or with a group of bytes. Such check bits are generated automatically by the machine and cannot be directly controlled by the program. Storage capacities are expressed in number of bytes. When the length of a storage-operand field is implied by the operation code of an instruction, the field is said to have a fixed length, which can be one, two, four, eight, or sixteen bytes. Larger fields may be implied for some instructions. When the length of a storage-operand field is not implied but is stated explicitly, the field is said to have a variable length. Variable-length operands can vary in length by increments of one byte (or with some instructions, in multiples of two bytes or other multiples). When information is placed in storage, the contents of only those byte locations are replaced that are included in the designated field, even though the width of the physical path to storage may be greater than the length of the field being stored.
Certain units of information are to be on an integral boundary in storage. A boundary is called integral for a unit of information when its storage address is a multiple of the length of the unit in bytes. Special names are given to fields of 2, 4, 8, 16, and 32 bytes on an integral boundary. A halfword is a group of two consecutive bytes on a two-byte boundary and is the basic building block of instructions. A word is a group of four consecutive bytes on a four-byte boundary. A doubleword is a group of eight consecutive bytes on an eight-byte boundary. A quadword is a group of 16 consecutive bytes on a 16-byte boundary. An octoword is a group of 32 consecutive bytes on a 32-byte boundary. When storage addresses designate halfwords, words, doublewords, quadwords, and octowords, the binary representation of the address contains one, two, three, four, or five rightmost zero bits, respectively. Instructions are to be on two-byte integral boundaries. The storage operands of most instructions do not have boundary-alignment requirements.
On devices that implement separate caches for instructions and data operands, a significant delay may be experienced if the program stores into a cache line from which instructions are subsequently fetched, regardless of whether the store alters the instructions that are subsequently fetched.
In one example, the embodiment may be practiced by software (sometimes referred to licensed internal code, firmware, micro-code, milli-code, pico-code and the like, any of which would be consistent with one or more embodiments). Referring to FIG. 18, software program code which embodies one or more aspects may be accessed by processor 5001 of the host system 5000 from long-term storage media devices 5011, such as a CD-ROM drive, tape drive or hard drive. The software program code may be embodied on any of a variety of known media for use with a data processing system, such as a diskette, hard drive, or CD-ROM. The code may be distributed on such media, or may be distributed to users from computer memory 5002 or storage of one computer system over a network 5010 to other computer systems for use by users of such other systems.
The software program code includes an operating system which controls the function and interaction of the various computer components and one or more application programs. Program code is normally paged from storage media device 5011 to the relatively higher-speed computer storage 5002 where it is available for processing by processor 5001. The techniques and methods for embodying software program code in memory, on physical media, and/or distributing software code via networks are well known and will not be further discussed herein. Program code, when created and stored on a tangible medium (including but not limited to electronic memory modules (RAM), flash memory, Compact Discs (CDs), DVDs, Magnetic Tape and the like is often referred to as a âcomputer program productâ. The computer program product medium is typically readable by a processing circuit preferably in a computer system for execution by the processing circuit.
 FIG. 19 illustrates a representative workstation or server hardware system in which one or more embodiments may be practiced. The system 5020 of FIG. 20 comprises a representative base computer system 5021, such as a personal computer, a workstation or a server, including optional peripheral devices. The base computer system 5021 includes one or more processors 5026 and a bus employed to connect and enable communication between the processor(s) 5026 and the other components of the system 5021 in accordance with known techniques. The bus connects the processor 5026 to memory 5025 and long-term storage 5027 which can include a hard drive (including any of magnetic media, CD, DVD and Flash Memory for example) or a tape drive for example. The system 5021 might also include a user interface adapter, which connects the microprocessor 5026 via the bus to one or more interface devices, such as a keyboard 5024, a mouse 5023, a printer/scanner 5030 and/or other interface devices, which can be any user interface device, such as a touch sensitive screen, digitized entry pad, etc. The bus also connects a display device 5022, such as an LCD screen or monitor, to the microprocessor 5026 via a display adapter.
The system 5021 may communicate with other computers or networks of computers by way of a network adapter capable of communicating 5028 with a network 5029. Example network adapters are communications channels, token ring, Ethernet or modems. Alternatively, the system 5021 may communicate using a wireless interface, such as a CDPD (cellular digital packet data) card. The system 5021 may be associated with such other computers in a Local Area Network (LAN) or a Wide Area Network (WAN), or the system 5021 can be a client in a client/server arrangement with another computer, etc. All of these configurations, as well as the appropriate communications hardware and software, are known in the art.
 FIG. 20 illustrates a data processing network 5040 in which one or more embodiments may be practiced. The data processing network 5040 may include a plurality of individual networks, such as a wireless network and a wired network, each of which may include a plurality of individual workstations 5041, 5042, 5043, 5044. Additionally, as those skilled in the art will appreciate, one or more LANs may be included, where a LAN may comprise a plurality of intelligent workstations coupled to a host processor.
Still referring to FIG. 20, the networks may also include mainframe computers or servers, such as a gateway computer (client server 5046) or application server (remote server 5048 which may access a data repository and may also be accessed directly from a workstation 5045). A gateway computer 5046 serves as a point of entry into each individual network. A gateway is needed when connecting one networking protocol to another. The gateway 5046 may be preferably coupled to another network (the Internet 5047 for example) by means of a communications link. The gateway 5046 may also be directly coupled to one or more workstations 5041, 5042, 5043, 5044 using a communications link. The gateway computer may be implemented utilizing one of an IBM Power Systems server and an IBM System z server available from International Business Machines Corporation.
Referring concurrently to FIG. 19 and FIG. 20, software programming code 5031 which may embody one or more aspects may be accessed by the processor 5026 of the system 5020 from long-term storage media 5027, such as a CD-ROM drive or hard drive. The software programming code may be embodied on any of a variety of known media for use with a data processing system, such as a diskette, hard drive, or CD-ROM. The code may be distributed on such media, or may be distributed to users 5050, 5051 from the memory or storage of one computer system over a network to other computer systems for use by users of such other systems.
Alternatively, the programming code may be embodied in the memory 5025, and accessed by the processor 5026 using the processor bus. Such programming code includes an operating system which controls the function and interaction of the various computer components and one or more application programs 5032. Program code is normally paged from storage media 5027 to high-speed memory 5025 where it is available for processing by the processor 5026. The techniques and methods for embodying software programming code in memory, on physical media, and/or distributing software code via networks are well known and will not be further discussed herein. Program code, when created and stored on a tangible medium (including but not limited to electronic memory modules (RAM), flash memory, Compact Discs (CDs), DVDs, Magnetic Tape and the like is often referred to as a âcomputer program productâ. The computer program product medium is typically readable by a processing circuit preferably in a computer system for execution by the processing circuit.
The cache that is most readily available to the processor (normally faster and smaller than other caches of the processor) is the lowest (L1 or level one) cache and main store (main memory) is the highest level cache (L3 if there are 3 levels). The lowest level cache is often divided into an instruction cache (I-Cache) holding machine instructions to be executed and a data cache (D-Cache) holding data operands.
Referring to FIG. 21, an exemplary processor embodiment is depicted for processor 5026. Typically one or more levels of cache 5053 are employed to buffer memory blocks in order to improve processor performance. The cache 5053 is a high speed buffer holding cache lines of memory data that are likely to be used. Typical cache lines are 64, 128 or 256 bytes of memory data. Separate caches are often employed for caching instructions than for caching data. Cache coherence (synchronization of copies of lines in memory and the caches) is often provided by various âsnoopâ algorithms well known in the art. Main memory storage 5025 of a processor system is often referred to as a cache. In a processor system having 4 levels of cache 5053, main storage 5025 is sometimes referred to as the level 5 (L5) cache since it is typically faster and only holds a portion of the non-volatile storage (DASD, tape etc) that is available to a computer system. Main storage 5025 âcachesâ pages of data paged in and out of the main storage 5025 by the operating system.
A program counter (instruction counter) 5061 keeps track of the address of the current instruction to be executed. A program counter in a z/Architecture processor is 64 bits and can be truncated to 31 or 24 bits to support prior addressing limits. A program counter in a Power Architecture processor is 64 bits and can be truncated to 32 bits to support prior addressing limits. A program counter is typically embodied in a PSW (program status word) of a computer such that it persists during context switching. Thus, a program in progress, having a program counter value, may be interrupted by, for example, the operating system (context switch from the program environment to the operating system environment). The PSW of the program maintains the program counter value while the program is not active, and the program counter (in the PSW) of the operating system is used while the operating system is executing. Typically, the program counter is incremented by an amount equal to the number of bytes of the current instruction. RISC (Reduced Instruction Set Computing) instructions are typically fixed length while CISC (Complex Instruction Set Computing) instructions are typically variable length. Instructions of the IBM z/Architecture are CISC instructions having a length of 2, 4 or 6 bytes. Instructions of the IBM Power ISA are RISC instructions having a length of 4 bytes. The Program counter 5061 is modified by either a context switch operation or a branch taken operation of a branch instruction for example. In a context switch operation, the current program counter value is saved in the program status word along with other state information about the program being executed (such as condition codes), and a new program counter value is loaded pointing to an instruction of a new program module to be executed. A branch taken operation is performed in order to permit the program to make decisions or loop within the program by loading the result of the branch instruction into the program counter 5061.
Typically an instruction fetch unit 5055 is employed to fetch instructions on behalf of the processor 5026. The fetch unit either fetches ânext sequential instructionsâ, target instructions of branch taken instructions, or first instructions of a program following a context switch. Modern Instruction fetch units often employ prefetch techniques to speculatively prefetch instructions based on the likelihood that the prefetched instructions might be used. For example, a fetch unit may fetch 16 bytes of instruction that includes the next sequential instruction and additional bytes of further sequential instructions.
The fetched instructions are then executed by the processor 5026. In an embodiment, the fetched instruction(s) are passed to a dispatch unit 5056 of the fetch unit. The dispatch unit decodes the instruction(s) and forwards information about the decoded instruction(s) to appropriate units 5057, 5058, 5060. An execution unit 5057 will typically receive information about decoded arithmetic instructions from the instruction fetch unit 5055 and will perform arithmetic operations on operands according to the opcode of the instruction. Operands are provided to the execution unit 5057 preferably either from memory 5025, architected registers 5059 or from an immediate field of the instruction being executed. Results of the execution, when stored, are stored either in memory 5025, registers 5059 or in other machine hardware (such as control registers, PSW registers and the like).
Virtual addresses are transformed into real addresses using dynamic address translation 5062 and, optionally, using access register translation 5063.
A processor 5026 typically has one or more units 5057, 5058, 5060 for executing the function of the instruction. Referring to FIG. 22A, an execution unit 5057 may communicate 5071 with architected general registers 5059, a decode/dispatch unit 5056, a load store unit 5060, and other 5065 processor units by way of interfacing logic 5071. An execution unit 5057 may employ several register circuits 5067, 5068, 5069 to hold information that the arithmetic logic unit (ALU) 5066 will operate on. The ALU performs arithmetic operations such as add, subtract, multiply and divide as well as logical function such as and, or and exclusive-or (XOR), rotate and shift. Preferably the ALU supports specialized operations that are design dependent. Other circuits may provide other architected facilities 5072 including condition codes and recovery support logic for example. Typically the result of an ALU operation is held in an output register circuit 5070 which can forward the result to a variety of other processing functions. There are many arrangements of processor units, the present description is only intended to provide a representative understanding of one embodiment.
An ADD instruction for example would be executed in an execution unit 5057 having arithmetic and logical functionality while a floating point instruction for example would be executed in a floating point execution having specialized floating point capability. Preferably, an execution unit operates on operands identified by an instruction by performing an opcode defined function on the operands. For example, an ADD instruction may be executed by an execution unit 5057 on operands found in two registers 5059 identified by register fields of the instruction.
The execution unit 5057 performs the arithmetic addition on two operands and stores the result in a third operand where the third operand may be a third register or one of the two source registers. The execution unit preferably utilizes an Arithmetic Logic Unit (ALU) 5066 that is capable of performing a variety of logical functions such as Shift, Rotate, And, Or and XOR as well as a variety of algebraic functions including any of add, subtract, multiply, divide. Some ALUs 5066 are designed for scalar operations and some for floating point. Data may be Big Endian (where the least significant byte is at the highest byte address) or Little Endian (where the least significant byte is at the lowest byte address) depending on architecture. The IBM z/Architecture is Big Endian. The IBM Power ISA supports both Big Endian and Little Endian execution modes. Signed fields may be sign and magnitude, 1's complement or 2's complement depending on architecture. A 2's complement number is advantageous in that the ALU does not need to design a subtract capability since either a negative value or a positive value in 2's complement requires only an addition within the ALU. Numbers are commonly described in shorthand, where a 12 bit field defines an address of a 4,096 byte block and is commonly described as a 4 Kbyte (Kilo-byte) block, for example.
Referring to FIG. 22B, branch instruction information for executing a branch instruction is typically sent to a branch unit 5058 which often employs a branch prediction algorithm such as a branch history table 5082 to predict the outcome of the branch before other conditional operations are complete. The target of the current branch instruction will be fetched and speculatively executed before the conditional operations are complete. When the conditional operations are completed the speculatively executed branch instructions are either completed or discarded based on the conditions of the conditional operation and the speculated outcome. A typical branch instruction may test condition codes and branch to a target address if the condition codes meet the branch requirement of the branch instruction, a target address may be calculated based on several numbers including ones found in register fields or an immediate field of the instruction for example. The branch unit 5058 may employ an ALU 5074 having a plurality of input register circuits 5075, 5076, 5077 and an output register circuit 5080. The branch unit 5058 may communicate 5081 with general registers 5059, decode dispatch unit 5056 or other circuits 5073, for example.
The execution of a group of instructions can be interrupted for a variety of reasons including a context switch initiated by an operating system, a program exception or error causing a context switch, an I/O interruption signal causing a context switch or multi-threading activity of a plurality of programs (in a multi-threaded environment), for example. Preferably a context switch action saves state information about a currently executing program and then loads state information about another program being invoked. State information may be saved in hardware registers or in memory for example. State information preferably comprises a program counter value pointing to a next instruction to be executed, condition codes, memory translation information and architected register content. A context switch activity can be exercised by hardware circuits, application programs, operating system programs or firmware code (microcode, pico-code or licensed internal code (LIC)) alone or in combination.
A processor accesses operands according to instruction defined methods. The instruction may provide an immediate operand using the value of a portion of the instruction, may provide one or more register fields explicitly pointing to either general purpose registers or special purpose registers (floating point registers for example). The instruction may utilize implied registers identified by an opcode field as operands. The instruction may utilize memory locations for operands. A memory location of an operand may be provided by a register, an immediate field, or a combination of registers and immediate field as exemplified by the z/Architecture long displacement facility wherein the instruction defines a base register, an index register and an immediate field (displacement field) that are added together to provide the address of the operand in memory for example; or the Power ISA addressing modes wherein D-Form addresses define a base register and an immediate field (displacement field) that are added together to provide the address of the operand in memory; and wherein X-Form addresses define a base register and an index register that are added together to provide the address of the operand in memory. Location herein typically implies a location in main memory (main storage) unless otherwise indicated.
Referring to FIG. 22C, a processor accesses storage using a load/store unit 5060. The load/store unit 5060 may perform a load operation by obtaining the address of the target operand in memory 5053 and loading the operand in a register 5059 or another memory 5053 location, or may perform a store operation by obtaining the address of the target operand in memory 5053 and storing data obtained from a register 5059 or another memory 5053 location in the target operand location in memory 5053. The load/store unit 5060 may be speculative and may access memory in a sequence that is out-of-order relative to instruction sequence, however the load/store unit 5060 is to maintain the appearance to programs that instructions were executed in order. A load/store unit 5060 may communicate 5084 with general registers 5059, decode/dispatch unit 5056, cache/memory interface 5053 or other elements 5083 and comprises various register circuits 5086, 5087, 5088 and 5089, ALUs 5085 and control logic 5090 to calculate storage addresses and to provide pipeline sequencing to keep operations in-order. Some operations may be out of order but the load/store unit provides functionality to make the out of order operations to appear to the program as having been performed in order, as is well known in the art.
Preferably addresses that an application program âseesâ are often referred to as virtual addresses. Virtual addresses are sometimes referred to as âlogical addressesâ and âeffective addressesâ. These virtual addresses are virtual in that they are redirected to physical memory location by one of a variety of dynamic address translation (DAT) technologies including, but not limited to, simply prefixing a virtual address with an offset value, translating the virtual address via one or more translation tables, the translation tables preferably comprising at least a segment table and a page table alone or in combination, preferably, the segment table having an entry pointing to the page table. In the z/Architecture, a hierarchy of translation is provided including a region first table, a region second table, a region third table, a segment table and an optional page table. The performance of the address translation is often improved by utilizing a translation lookaside buffer (TLB) which comprises entries mapping a virtual address to an associated physical memory location. The entries are created when the DAT translates a virtual address using the translation tables. Subsequent use of the virtual address can then utilize the entry of the fast TLB rather than the slow sequential translation table accesses. TLB content may be managed by a variety of replacement algorithms including LRU (Least Recently used).
In the case where the processor is a processor of a multi-processor system, each processor has responsibility to keep shared resources, such as I/O, caches, TLBs and memory, interlocked for coherency. Typically, âsnoopâ technologies will be utilized in maintaining cache coherency. In a snoop environment, each cache line may be marked as being in any one of a shared state, an exclusive state, a changed state, an invalid state and the like in order to facilitate sharing.
I/O units 5054 (FIG. 21) provide the processor with means for attaching to peripheral devices including tape, disc, printers, displays, and networks for example. I/O units are often presented to the computer program by software drivers. In mainframes, such as the System z from IBMÂ®, channel adapters and open system adapters are I/O units of the mainframe that provide the communications between the operating system and peripheral devices. In RISC servers, such as Power Systems from IBMÂ®, proprietary adapters and open system adapters are I/O units that provide the communications between the operating system and peripheral devices.
Further, other types of computing environments can benefit from one or more aspects. As an example, an environment may include an emulator (e.g., software or other emulation mechanisms), in which a particular architecture (including, for instance, instruction execution, architected functions, such as address translation, and architected registers) or a subset thereof is emulated (e.g., on a native computer system having a processor and memory). In such an environment, one or more emulation functions of the emulator can implement one or more embodiments, even though a computer executing the emulator may have a different architecture than the capabilities being emulated. As one example, in emulation mode, the specific instruction or operation being emulated is decoded, and an appropriate emulation function is built to implement the individual instruction or operation.
In an emulation environment, a host computer includes, for instance, a memory to store instructions and data; an instruction fetch unit to fetch instructions from memory and to optionally, provide local buffering for the fetched instruction; an instruction decode unit to receive the fetched instructions and to determine the type of instructions that have been fetched; and an instruction execution unit to execute the instructions. Execution may include loading data into a register from memory; storing data back to memory from a register; or performing some type of arithmetic or logical operation, as determined by the decode unit. In one example, each unit is implemented in software. For instance, the operations being performed by the units are implemented as one or more subroutines within emulator software.
More particularly, in a mainframe, architected machine instructions are used by programmers, usually today âCâ programmers, often by way of a compiler application. These instructions stored in the storage medium may be executed natively in a Power Systems or a z/Architecture IBMÂ® Server, or alternatively in machines executing other architectures. They can be emulated in the existing and in future IBMÂ® mainframe servers, Power Systems servers and on other machines of IBMÂ® (e.g., System x Servers). They can be executed in machines running Linux on a wide variety of machines using hardware manufactured by IBMÂ®, IntelÂ®, AMD, and others. Besides execution on that hardware under a Power Architecture or z/Architecture, Linux can be used as well as machines which use emulation by Hercules, UMX, or FSI (Fundamental Software, Inc), where generally execution is in an emulation mode. In emulation mode, emulation software is executed by a native processor to emulate the architecture of an emulated processor.
The native processor typically executes emulation software comprising either firmware or a native operating system to perform emulation of the emulated processor. The emulation software is responsible for fetching and executing instructions of the emulated processor architecture. The emulation software maintains an emulated program counter to keep track of instruction boundaries. The emulation software may fetch one or more emulated machine instructions at a time and convert the one or more emulated machine instructions to a corresponding group of native machine instructions for execution by the native processor. These converted instructions may be cached such that a faster conversion can be accomplished. Notwithstanding, the emulation software is to maintain the architecture rules of the emulated processor architecture so as to assure operating systems and applications written for the emulated processor operate correctly. Furthermore, the emulation software is to provide resources identified by the emulated processor architecture including, but not limited to, control registers, general purpose registers, floating point registers, dynamic address translation function including segment tables and page tables for example, interrupt mechanisms, context switch mechanisms, Time of Day (TOD) clocks and architected interfaces to I/O subsystems such that an operating system or an application program designed to run on the emulated processor, can be run on the native processor having the emulation software.
A specific instruction being emulated is decoded, and a subroutine is called to perform the function of the individual instruction. An emulation software function emulating a function of an emulated processor is implemented, for example, in a âCâ subroutine or driver, or some other method of providing a driver for the specific hardware as will be within the skill of those in the art after understanding the description of the preferred embodiment. Various software and hardware emulation patents including, but not limited to U.S. Letters Patent No. 5,551,013, entitled âMultiprocessor for Hardware Emulationâ, by Beausoleil et al.; and U.S. Letters Patent No. 6,009,261, entitled âPreprocessing of Stored Target Routines for Emulating Incompatible Instructions on a Target Processorâ, by Scalzi et al; and U.S. Letters Patent No. 5,574,873, entitled âDecoding Guest Instruction to Directly Access Emulation Routines that Emulate the Guest Instructionsâ, by Davidian et al; and U.S. Letters Patent No. 6,308,255, entitled âSymmetrical Multiprocessing Bus and Chipset Used for Coprocessor Support Allowing Non-Native Code to Run in a Systemâ, by Gorishek et al; and U.S. Letters Patent No. 6,463,582, entitled âDynamic Optimizing Object Code Translator for Architecture Emulation and Dynamic Optimizing Object Code Translation Methodâ, by Lethin et al; and U.S. Letters Patent No. 5,790,825, entitled âMethod for Emulating Guest Instructions on a Host Computer Through Dynamic Recompilation of Host Instructionsâ, by Eric Traut, each of which is hereby incorporated herein by reference in its entirety; and many others, illustrate a variety of known ways to achieve emulation of an instruction format architected for a different machine for a target machine available to those skilled in the art.
In FIG. 23, an example of an emulated host computer system 5092 is provided that emulates a host computer system 5000â² of a host architecture. In the emulated host computer system 5092, the host processor (CPU) 5091 is an emulated host processor (or virtual host processor) and comprises an emulation processor 5093 having a different native instruction set architecture than that of the processor 5091 of the host computer 5000â². The emulated host computer system 5092 has memory 5094 accessible to the emulation processor 5093. In the example embodiment, the memory 5094 is partitioned into a host computer memory 5096 portion and an emulation routines 5097 portion. The host computer memory 5096 is available to programs of the emulated host computer 5092 according to host computer architecture. The emulation processor 5093 executes native instructions of an architected instruction set of an architecture other than that of the emulated processor 5091, the native instructions obtained from emulation routines memory 5097, and may access a host instruction for execution from a program in host computer memory 5096 by employing one or more instruction(s) obtained in a sequence & access/decode routine which may decode the host instruction(s) accessed to determine a native instruction execution routine for emulating the function of the host instruction accessed. Other facilities that are defined for the host computer system 5000â² architecture may be emulated by architected facilities routines, including such facilities as general purpose registers, control registers, dynamic address translation and I/O subsystem support and processor cache, for example. The emulation routines may also take advantage of functions available in the emulation processor 5093 (such as general registers and dynamic translation of virtual addresses) to improve performance of the emulation routines. Special hardware and off-load engines may also be provided to assist the processor 5093 in emulating the function of the host computer 5000â².
In a further embodiment, one or more aspects relate to cloud computing. It is understood in advance that although this disclosure includes a detailed description on cloud computing, implementation of the teachings recited herein are not limited to a cloud computing environment. Rather, embodiments of the present invention are capable of being implemented in conjunction with any other type of computing environment now known or later developed.
Cloud computing is a model of service delivery for enabling convenient, on-demand network access to a shared pool of configurable computing resources (e.g. networks, network bandwidth, servers, processing, memory, storage, applications, virtual machines, and services) that can be rapidly provisioned and released with minimal management effort or interaction with a provider of the service. This cloud model may include at least five characteristics, at least three service models, and at least four deployment models.
Characteristics are as follows:
On-demand self-service: a cloud consumer can unilaterally provision computing capabilities, such as server time and network storage, as needed automatically without requiring human interaction with the service's provider.
Broad network access: capabilities are available over a network and accessed through standard mechanisms that promote use by heterogeneous thin or thick client platforms (e.g., mobile phones, laptops, and PDAs).
Resource pooling: the provider's computing resources are pooled to serve multiple consumers using a multi-tenant model, with different physical and virtual resources dynamically assigned and reassigned according to demand. There is a sense of location independence in that the consumer generally has no control or knowledge over the exact location of the provided resources but may be able to specify location at a higher level of abstraction (e.g., country, state, or datacenter).
Rapid elasticity: capabilities can be rapidly and elastically provisioned, in some cases automatically, to quickly scale out and rapidly released to quickly scale in. To the consumer, the capabilities available for provisioning often appear to be unlimited and can be purchased in any quantity at any time.
Measured service: cloud systems automatically control and optimize resource use by leveraging a metering capability at some level of abstraction appropriate to the type of service (e.g., storage, processing, bandwidth, and active user accounts). Resource usage can be monitored, controlled, and reported providing transparency for both the provider and consumer of the utilized service.
Service Models are as follows:
Software as a Service (SaaS): the capability provided to the consumer is to use the provider's applications running on a cloud infrastructure. The applications are accessible from various client devices through a thin client interface such as a web browser (e.g., web-based email). The consumer does not manage or control the underlying cloud infrastructure including network, servers, operating systems, storage, or even individual application capabilities, with the possible exception of limited user-specific application configuration settings.
Platform as a Service (PaaS): the capability provided to the consumer is to deploy onto the cloud infrastructure consumer-created or acquired applications created using programming languages and tools supported by the provider. The consumer does not manage or control the underlying cloud infrastructure including networks, servers, operating systems, or storage, but has control over the deployed applications and possibly application hosting environment configurations.
Infrastructure as a Service (IaaS): the capability provided to the consumer is to provision processing, storage, networks, and other fundamental computing resources where the consumer is able to deploy and run arbitrary software, which can include operating systems and applications. The consumer does not manage or control the underlying cloud infrastructure but has control over operating systems, storage, deployed applications, and possibly limited control of select networking components (e.g., host firewalls).
Deployment Models are as follows:
Private cloud: the cloud infrastructure is operated solely for an organization. It may be managed by the organization or a third party and may exist on-premises or off-premises.
Community cloud: the cloud infrastructure is shared by several organizations and supports a specific community that has shared concerns (e.g., mission, security requirements, policy, and compliance considerations). It may be managed by the organizations or a third party and may exist on-premises or off-premises.
Public cloud: the cloud infrastructure is made available to the general public or a large industry group and is owned by an organization selling cloud services.
Hybrid cloud: the cloud infrastructure is a composition of two or more clouds (private, community, or public) that remain unique entities but are bound together by standardized or proprietary technology that enables data and application portability (e.g., cloud bursting for loadbalancing between clouds).
A cloud computing environment is service oriented with a focus on statelessness, low coupling, modularity, and semantic interoperability. At the heart of cloud computing is an infrastructure comprising a network of interconnected nodes.
Referring now to FIG. 24, a schematic of an example of a cloud computing node is shown. Cloud computing node 6010 is only one example of a suitable cloud computing node and is not intended to suggest any limitation as to the scope of use or functionality of embodiments of the invention described herein. Regardless, cloud computing node 6010 is capable of being implemented and/or performing any of the functionality set forth hereinabove.
In cloud computing node 6010 there is a computer system/server 6012, which is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well-known computing systems, environments, and/or configurations that may be suitable for use with computer system/server 6012 include, but are not limited to, personal computer systems, server computer systems, thin clients, thick clients, handheld or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputer systems, mainframe computer systems, and distributed cloud computing environments that include any of the above systems or devices, and the like.
Computer system/server 6012 may be described in the general context of computer system executable instructions, such as program modules, being executed by a computer system. Generally, program modules may include routines, programs, objects, components, logic, data structures, and so on that perform particular tasks or implement particular abstract data types. Computer system/server 6012 may be practiced in distributed cloud computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed cloud computing environment, program modules may be located in both local and remote computer system storage media including memory storage devices.
As shown in FIG. 24, computer system/server 6012 in cloud computing node 6010 is shown in the form of a general-purpose computing device. The components of computer system/server 6012 may include, but are not limited to, one or more processors or processing units 6016, a system memory 6028, and a bus 6018 that couples various system components including system memory 6028 to processor 6016.
Bus 6018 represents one or more of any of several types of bus structures, including a memory bus or memory controller, a peripheral bus, an accelerated graphics port, and a processor or local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus.
Computer system/server 6012 typically includes a variety of computer system readable media. Such media may be any available media that is accessible by computer system/server 6012, and it includes both volatile and non-volatile media, removable and non-removable media.
System memory 6028 can include computer system readable media in the form of volatile memory, such as random access memory (RAM) 6030 and/or cache memory 6032. Computer system/server 6012 may further include other removable/non-removable, volatile/non-volatile computer system storage media. By way of example only, storage system 6034 can be provided for reading from and writing to a non-removable, non-volatile magnetic media (not shown and typically called a âhard driveâ). Although not shown, a magnetic disk drive for reading from and writing to a removable, non-volatile magnetic disk (e.g., a âfloppy diskâ), and an optical disk drive for reading from or writing to a removable, non-volatile optical disk such as a CD-ROM, DVD-ROM or other optical media can be provided. In such instances, each can be connected to bus 6018 by one or more data media interfaces. As will be further depicted and described below, memory 6028 may include at least one program product having a set (e.g., at least one) of program modules that are configured to carry out the functions of embodiments of the invention.
Program/utility 6040, having a set (at least one) of program modules 6042, may be stored in memory 6028 by way of example, and not limitation, as well as an operating system, one or more application programs, other program modules, and program data. Each of the operating system, one or more application programs, other program modules, and program data or some combination thereof, may include an implementation of a networking environment. Program modules 6042 generally carry out the functions and/or methodologies of embodiments of the invention as described herein.
Computer system/server 6012 may also communicate with one or more external devices 6014 such as a keyboard, a pointing device, a display 6024, etc.; one or more devices that enable a user to interact with computer system/server 6012; and/or any devices (e.g., network card, modem, etc.) that enable computer system/server 6012 to communicate with one or more other computing devices. Such communication can occur via Input/Output (I/O) interfaces 6022. Still yet, computer system/server 6012 can communicate with one or more networks such as a local area network (LAN), a general wide area network (WAN), and/or a public network (e.g., the Internet) via network adapter 6020. As depicted, network adapter 6020 communicates with the other components of computer system/server 6012 via bus 6018. It should be understood that although not shown, other hardware and/or software components could be used in conjunction with computer system/server 6012. Examples, include, but are not limited to: microcode, device drivers, redundant processing units, external disk drive arrays, RAID systems, tape drives, and data archival storage systems, etc.
Referring now to FIG. 25, illustrative cloud computing environment 6050 is depicted. As shown, cloud computing environment 6050 comprises one or more cloud computing nodes 6010 with which local computing devices used by cloud consumers, such as, for example, personal digital assistant (PDA) or cellular telephone 6054A, desktop computer 6054B, laptop computer 6054C, and/or automobile computer system 6054N may communicate. Nodes 6010 may communicate with one another. They may be grouped (not shown) physically or virtually, in one or more networks, such as Private, Community, Public, or Hybrid clouds as described hereinabove, or a combination thereof. This allows cloud computing environment 6050 to offer infrastructure, platforms and/or software as services for which a cloud consumer does not need to maintain resources on a local computing device. It is understood that the types of computing devices 6054A-N shown in FIG. 25 are intended to be illustrative only and that computing nodes 6010 and cloud computing environment 6050 can communicate with any type of computerized device over any type of network and/or network addressable connection (e.g., using a web browser).
Referring now to FIG. 26, a set of functional abstraction layers provided by cloud computing environment 6050 (FIG. 25) is shown. It should be understood in advance that the components, layers, and functions shown in FIG. 26 are intended to be illustrative only and embodiments of the invention are not limited thereto. As depicted, the following layers and corresponding functions are provided:
Hardware and software layer 6060 includes hardware and software components. Examples of hardware components include mainframes, in one example IBMÂ® zSeriesÂ® systems; RISC (Reduced Instruction Set Computer) architecture based servers, in one example IBM pSeriesÂ® systems; IBM xSeriesÂ® systems; IBM BladeCenterÂ® systems; storage devices; networks and networking components. Examples of software components include network application server software, in one example IBM WebSphereÂ® application server software; and database software, in one example IBM DB2Â® database software. (IBM, zSeries, pSeries, xSeries, BladeCenter, WebSphere, and DB2 are trademarks of International Business Machines Corporation registered in many jurisdictions worldwide).
Virtualization layer 6062 provides an abstraction layer from which the following examples of virtual entities may be provided: virtual servers; virtual storage; virtual networks, including virtual private networks; virtual applications and operating systems; and virtual clients.
In one example, management layer 6064 may provide the functions described below. Resource provisioning provides dynamic procurement of computing resources and other resources that are utilized to perform tasks within the cloud computing environment. Metering and Pricing provide cost tracking as resources are utilized within the cloud computing environment, and billing or invoicing for consumption of these resources. In one example, these resources may comprise application software licenses. Security provides identity verification for cloud consumers and tasks, as well as protection for data and other resources. User portal provides access to the cloud computing environment for consumers and system administrators. Service level management provides cloud computing resource allocation and management such that required service levels are met. Service Level Agreement (SLA) planning and fulfillment provide pre-arrangement for, and procurement of, cloud computing resources for which a future requirement is anticipated in accordance with an SLA.
Workloads layer 6066 provides examples of functionality for which the cloud computing environment may be utilized. Examples of workloads and functions which may be provided from this layer include: mapping and navigation; software development and lifecycle management; virtual classroom education delivery; data analytics processing; and transaction processing.
The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting. As used herein, the singular forms âaâ, âanâ and âtheâ are intended to include the plural forms as well, unless the context clearly indicates otherwise. It will be further understood that the terms âcomprisesâ and/or âcomprisingâ, when used in this specification, specify the presence of stated features, integers, steps, operations, elements, and/or components, but do not preclude the presence or addition of one or more other features, integers, steps, operations, elements, components and/or groups thereof.
The corresponding structures, materials, acts, and equivalents of all means or step plus function elements in the claims below, if any, are intended to include any structure, material, or act for performing the function in combination with other claimed elements as specifically claimed. The description of one or more embodiments has been presented for purposes of illustration and description, but is not intended to be exhaustive or limited to in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain various aspects and the practical application, and to enable others of ordinary skill in the art to understand various embodiments with various modifications as are suited to the particular use contemplated.