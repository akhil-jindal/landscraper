Structured data in a business networking feed 
US-9824082-B2
Salesforce.Com, Inc.
2017-11-21
https://patents.google.com/patent/US9824082B2/en
PRIORITY DATA
This patent document is a continuation of and claims priority to and commonly assigned U.S. patent application Ser. No. 14/642,063, titled âStructured Data in a Business Networking Feedâ, by Agrawal et al., filed on Mar. 9, 2015, which is a continuation of U.S. Pat. No. 9,031,957, titled âStructured Data in a Business Networking Feedâ, by Agrawal et al., filed on Mar. 11, 2011, which claims priority to U.S. Provisional Patent Application No. 61/391,246, titled âDatabase in a Business Networking Feedâ, by Agrawal et al., filed on Oct. 8, 2010. Each of U.S. patent application Ser. No. 14/642,063, U.S. Pat. No. 9,031,957, and U.S. Provisional Patent Application No. 61/391,246 is hereby incorporated by reference in its entirety and for all purposes.
COPYRIGHT NOTICE
A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.
TECHNICAL FIELD
The present disclosure relates generally to on-demand services provided over a data network such as the Internet, and more specifically to databases in a business networking service.
BACKGROUND
âCloud computingâ services provide shared resources, software, and information to computers and other devices upon request. In cloud computing environments, software can be accessible over the Internet rather than installed locally on in-house computer systems. Cloud computing typically involves over-the-Internet provision of dynamically scalable and often virtualized resources. Technological details can be abstracted from the users, who no longer have need for expertise in, or control over, the technology infrastructure âin the cloudâ that supports them.
Database resources can be provided in a cloud computing context. However, using conventional database management techniques, it is difficult to know about the activity of other users of a database system in the cloud or other network. For example, the actions of a particular user, such as a salesperson, on a database resource may be important to the user's boss. The user can create a report about what the user has done and send it to the boss, but such reports may be inefficient, not timely, and incomplete. Also, it may be difficult to identify other users who might benefit from the information in the report.

BRIEF DESCRIPTION OF THE DRAWINGS
The included drawings are for illustrative purposes and serve only to provide examples of possible structures and process operations for the disclosed inventive systems, apparatus, and methods for providing structured data objects for an information feed in an on-demand computing service environment. These drawings in no way limit any changes in form and detail that may be made by one skilled in the art without departing from the spirit and scope of the disclosed embodiments.
 FIG. 1A illustrates a block diagram of an example of an environment wherein an on-demand database service might be used.
 FIG. 1B illustrates a block diagram of an embodiment of elements of FIG. 1A and various possible interconnections between these elements.
 FIG. 2A shows a system diagram 200 illustrating architectural components of an on-demand service environment, in accordance with one embodiment.
 FIG. 2B shows a system diagram further illustrating architectural components of an on-demand service environment, in accordance with one embodiment.
 FIG. 3 is a flowchart of a method 300 for tracking updates to a record stored in a database system according to one or more embodiments.
 FIG. 4 is a block diagram of components of a database system performing a method for tracking an update to a record according to one or more embodiments.
 FIG. 5 is a flowchart of a method 500 for tracking actions of a user of a database system according to one or more embodiments.
 FIG. 6 is a flowchart of a method 600 for creating a news feed from messages created by a first user about a record or another user according to one or more embodiments.
 FIG. 7 shows an example of a group feed on a group page according to one or more embodiments.
 FIG. 8 shows an example of a record feed containing a feed tracked update, post, and comments according to one or more embodiments.
 FIG. 9A shows a plurality of tables that may be used in tracking events and creating feeds according to one or more embodiments.
 FIG. 9B shows a flowchart illustrating a method 900 for automatically subscribing a user to an object in a database system according to embodiments.
 FIG. 10 is a flowchart of a method 1000 for saving information to feed tracking tables according to one or more embodiments.
 FIG. 11 is a flowchart of a method 1100 for reading a feed item as part of generating a feed for display according to one or more embodiments.
 FIG. 12 is a flowchart of a method 1200 for reading a feed item of a profile feed for display according to one or more embodiments.
 FIG. 13 is a flowchart of a method 1300 of storing event information for efficient generation of feed items to display in a feed according to one or more embodiments.
 FIG. 14 is a flowchart of a method 1400 for creating a custom feed for users of a database system using filtering criteria according to one or more embodiments.
 FIG. 15 is a flowchart of a method 1500 for performing a structured data lifecycle according to one or more embodiments.
 FIG. 16 is a flowchart of a method 1600 for processing structured data according to one or more embodiments.
 FIG. 17 is a flowchart of a method 1700 for analyzing structured data according to one or more embodiments.
 FIG. 18 is a database configuration diagram 1800 of a database for storing structured data according to one or more embodiments.
 FIGS. 19-29 show images of user interfaces involving structured data according to one or more embodiments.

DETAILED DESCRIPTION
Examples of systems, apparatus, and methods according to the disclosed embodiments are described in this section. These examples are being provided solely to add context and aid in the understanding of the disclosed embodiments. It will thus be apparent to one skilled in the art that implementations may be practiced without some or all of these specific details. In other instances, well known process/method steps have not been described in detail in order to avoid unnecessarily obscuring embodiments. Other applications are possible, such that the following examples should not be taken as definitive or limiting either in scope or setting.
In the following detailed description, references are made to the accompanying drawings, which form a part of the description and in which are shown, by way of illustration, specific embodiments. Although these embodiments are described in sufficient detail to enable one skilled in the art to practice the disclosed implementations, it is understood that these examples are not limiting, such that other embodiments may be used and changes may be made without departing from their spirit and scope. For example, the blocks of methods shown and described herein are not necessarily performed in the order indicated. It should also be understood that the methods may include more or fewer blocks than are indicated. In some implementations, blocks described herein as separate blocks may be combined. Conversely, what may be described herein as a single block may be implemented in multiple blocks.
Various embodiments described or referenced herein are directed to different methods, apparatus, systems, and computer program products for receiving structured data to publish on an information feed in an on-demand database service environment. In some embodiments, the disclosed methods, apparatus, systems, and computer program products may be configured or designed for use in a multi-tenant database environment.
The âfollowingâ of a database record, as described in greater detail below, allows a user to track the progress of that record. Updates to the record, also referred to herein as changes, can occur and be noted on the record's information feed as well as the news feed of a user subscribed to the record. With the disclosed embodiments, updates are often presented as an item or entry in the feed, but can also be presented as a collection of individual of items. Types of such updates can include field changes in a data record, posts such as explicit text or characters submitted by a user, status updates, uploaded files, and links to other data or records. Also, one type of update is the creation of the record itself. Updates can also be group-related, e.g., a change to group status information for a group of which the user is a member. Users following the record are capable of viewing updates on the user's feed.
The disclosed implementations provide for uploading structured data to an organization-specific social networking system. Implementations of the disclosed systems, apparatus, and methods are also configured to process, analyze, and share the structured data.
In some embodiments, techniques are provided for sharing data using an organization-specific social networking feed. Users may upload structured and collaborate on it in the form of shared files. In some instances, techniques may be employed by end users, such as business users and social networking users, who may not be as technically sophisticated as administrators or developers.
In some embodiments, uploaded data and metadata may take the form of a database object. The uploaded data may be divided into rows and columns. Rows may correspond to data entries, while columns may correspond to data fields storing values for the data entries. Alternately, columns may correspond to data entries, while rows may correspond to data fields storing values for the data entries. Metadata may define data types, column or row names, a data object name, formulas for field values, or any other information.
In some embodiments, end users may be able to customize user-created objects. For example, users may perform platform customization operations such as adding new columns or fields, deleting columns or fields, moving the order of columns, modifying layouts, creating filtered list views, sharing an object, reporting on an object, adding validation rules, or other types of customization. At the same time, some users may be restricted from performing certain types of customizations, for example for security or complexity reasons.
In some embodiments, an on-demand database or spreadsheet editor may be provided. Using the on-demand editor, structured data uploaded to the social networking system may be edited directly via a user interface component provided in a web page. Users may have access to a single record form layout and/or a flexible multi-record grid. Users may have access to simple and powerful tools for manipulating, organizing, and sharing data.
Some embodiments may include tools for the simplified sharing of structured data. For example, since objects may be created and/or managed by end users, end users may also be able to share this data with their colleagues. Sharing of these structured files, spreadsheets, or databases may work much like sharing other files in the organization-specific social network. For example, a user may be able to upload a database to the user's profile, to a group, to a data record, or to some other construct of the social network.
In some embodiments, uploading data to the social networking system may allow a user to transform local data stored on the user's computer to shared data that may be collaborated on with other users via the social networking system. That is, rather than separately editing local versions of data, users can edit or view a shared version of the data. Further, the data may be stored directly within the system (e.g., in a database system), where it can be accessed, shared, viewed, edited, and used more directly than when the data is locked away in files.
In some embodiments, changes to the structured data may trigger updates via the social networking system. Updates may inform the followers about the addition, deletion, and/or modification of records. For example, an information feed may include indications that a data object was added to the system, that new data entries were added to an existing data object, or that data fields within an existing data entry were changed. Feeds may be at record level, object level, or both. For example, updates such as âOpportunity X is now closedâ or âThree new Opportunities were just added by John Doeâ may be sent. Users may be able to adjust these feeds via settings.
In one example of the use of structured data in a social networking system, Andrea and Scott are employees of a fictional company, Bluthe Real Estate Company. Andrea works in the marketing department as an event coordinator on a team of 20 people. Andrea is always looking for new ways to improve her day-to-day tasks. She is currently working with her team to plan an upcoming launch event for the new development project at Sutton Valley.
The planning of this event requires that she and her team manage lots of data together, such as purchases, timelines, vendors and deliverables. The team uses spreadsheets to track their data. Until now, the team has created many revisions of the list of vendors and their deliverables.
However, the team has no idea when data has changed and who has the latest version, unless they email the files to each other to stay up to date. There is also no convenient way to link the spreadsheet data with their existing data, such as existing data stored in an on-demand service environment. For example, there is no convenient way to link the spreadsheet data with details on the vendor accounts, account contacts, account contracts, past interactions with venders, and other existing data.
In some embodiments, a social networking database service may give users the power to use aspects of an on-demand computing services environment with little information technology (IT) investment. For example, Andrea can upload her existing spreadsheet to an organization-specific social networking environment group.
In some embodiments, Andrea can then access her data in a variety of layouts such as a traditional spreadsheet format or in a layout specified by the on-demand service environment. When the spreadsheet is uploaded to the group, Andrea's team members may be notified about the spreadsheet in their Chatter feeds. This object and data may be automatically shared with all the members of her group.
In some embodiments, Andrea can collaborate on the data with coworkers such as Scott. Scott may view the data about vendors being used for the launch of this event. Scott may also share the data with others. For example, Scott can share the data with his Chatter followers. As another example, Scott can share the data with specific Chatter groups. As yet another example, Scott can also share the data with other individuals in the organization.
In some embodiments, Andrea can move structured data from outside of the cloud into the on-demand service environment. When this data is stored in the cloud, Andrea and her team can use the power of the on-demand service environment for this data. For example, Andrea or Scott may be able to add new columns or custom fields to the structured data. As another example, they may be able to collaborate on validation rules. As yet another example, they may be able to build business processes for the structured data using a tool such as a visual process manager. As still another example, they may be able to build charts to report other data.
In some embodiments, users can create collaborative, real-time, and/or mobile applications to manage data rather than e-mailing spreadsheets back and forth. Users may be able to modify the application with minimal IT department involvement. Users may be more productive because data flows directly through the on-demand service environment.
These and other embodiments may be implemented by various types of hardware, software, firmware, etc. For example, some embodiments may be implemented, at least in part, by machine-readable media that include program instructions, state information, etc., for performing various services and operations described herein. Examples of program instructions include both machine code, such as produced by a compiler, and files containing higher-level code that may be executed by the computer using an interpreter. Examples of machine-readable media include, but are not limited to, magnetic media such as hard disks, floppy disks, and magnetic tape; optical media such as CD-ROM disks; magneto-optical media; and hardware devices that are specially configured to store program instructions, such as read-only memory devices (âROMâ) and random access memory (âRAMâ). These and other features and benefits of the disclosed embodiments will be described in more detail below with reference to the associated drawings.
The term âmulti-tenant database systemâ can refer to those systems in which various elements of hardware and software of the database system may be shared by one or more customers. For example, a given application server may simultaneously process requests for a great number of customers, and a given database table may store rows for a potentially much greater number of customers. The term âquery planâ generally refers to one or more steps used to access information in a database system.
A âuser profileâ or âuser's profileâ is generally configured to store and maintain data about the user of the database system. The data can include general information, such as title, phone number, a photo, a biographical summary, and a status (e.g., text describing what the user is currently doing). As mentioned below, the data can include messages created by other users. Where there are multiple tenants, a user is typically associated with a particular tenant. For example, a user could be a salesperson of a company that is a tenant of the database system that provides a database service.
The term ârecordâ generally refers to a data entity, such as an instance of a data object created by a user of the database service, for example, about a particular (actual or potential) business relationship or project. The data object can have a data structure defined by the database service (a standard object) or defined by a subscriber (custom object). For example, a record can be for a business partner or potential business partner (e.g. a client, vendor, distributor, etc.) of the user, and can include an entire company, subsidiaries, or contacts at the company. As another example, a record can be a project that the user is working on, such as an opportunity (e.g. a possible sale) with an existing partner, or a project that the user is trying to get. In one embodiment implementing a multi-tenant database, all of the records for the tenants have an identifier stored in a common table. A record has data fields that are defined by the structure of the object (e.g. fields of certain data types and purposes). A record can also have custom fields defined by a user. A field can be another record or include links thereto, thereby providing a parent-child relationship between the records.
The term âfeedâ includes a combination (e.g. a list) of feed items or entries with various types of information and data. Such feed items can be stored and maintained in one or more database tables, e.g., as rows in the table(s), that can be accessed to retrieve relevant information to be presented as part of a displayed feed. The term âfeed itemâ (or feed element) refers to information about a user (âprofile feedâ) of the database or about a record (ârecord feedâ) in the database. A user following the user or record can receive the associated feed items. In some implementations, the feed items from all of the followed users and records can be combined into a single feed for the user.
As examples, a feed item can be a message, such as a user-generated post of text data, and a feed tracked update to a record or profile, such as a change to a field of the record. A feed can be a combination of messages and feed tracked updates. Messages include text created by a user, and may include other data as well. Examples of messages include posts, user status updates, and comments. Messages can be created for a user's profile or for a record. Posts can be created by various users, potentially any user, although some restrictions can be applied. As an example, posts can be made to a wall section of a user's profile (which can include a number of recent posts) or a section of a record that includes multiple posts. The posts can be organized in chronological order when displayed in a graphical user interface (GUI) as part of a feed. In contrast to a post, a user status update changes a status of a user and can be made by that user or an administrator. Other similar sections of a user's profile can also include an âAboutâ section. A record can also have a status, whose update can be provided by an owner of the record or other users having suitable write access permissions to the record. The owner can be a single user, multiple users, or a group. In one embodiment, there is only one status for a record. In one embodiment, a comment can be made on any feed item. In another embodiment, comments are organized as a list explicitly tied to a particular feed tracked update, post, or status update. In this embodiment, comments may not be listed in the first layer (in a hierarchal sense) of feed items, but listed as a second layer branching from a particular first layer feed item.
A âfeed tracked update,â also referred to herein as a âfeed update,â generally refers to data representing an event, and can include text generated by the database system in response to the event, to be provided as one or more feed items for possible inclusion in one or more feeds. In one embodiment, the data can initially be stored, and then the database system can later use the data to create text for describing the event. Both the data and/or the text can be a feed tracked update, as used herein. In various embodiments, an event can be an update of a record and/or can be triggered by a specific action by a user. Which actions trigger an event can be configurable. Which events have feed tracked updates created and which feed updates are sent to which users can also be configurable. Messages and feed updates can be stored as a field or child object of the record. For example, the feed can be stored as a child object of the record.
A âgroupâ is generally a collection of users. In some aspects, the group may be defined as users with a same or similar attribute, or by membership. In one embodiment, a âgroup feedâ includes any feed item about any user in a group. In another embodiment, the group feed includes feed items that are about the group as a whole. In one implementation, the feed items for a group are only posts and comments.
An âentity feedâ or ârecord feedâ generally refers to a feed of feed items about a particular record in the database, such as feed tracked updates about changes to the record and posts made by users about the record. An entity feed can be composed of any type of feed item. Such a feed can be displayed on a page (e.g. a web page) associated with the record (e.g. a home page of the record). As used herein, a âprofile feedâ is a feed of feed items about a particular user. In one embodiment, the feed items for a profile feed are posts and comments that other users make about or send to the particular user, and status updates made by the user. Such a profile feed can be displayed on a page associated with the particular user. In another embodiment, feed items in a profile feed could include posts made by the particular user and feed tracked changes (feed tracked updates) initiated based on actions of the particular user.
I. General Overview
Systems, apparatus, and methods are provided for implementing enterprise level social and business information networking. Such embodiments can provide more efficient use of a database system. For instance, a user of a database system may not easily know when important information in the database has changed, e.g., about a project or client. Embodiments can provide feed tracked updates about such changes and other events, thereby keeping users informed.
By way of example, a user can update a record (e.g. an opportunity such as a possible sale of 1000 computers). Once the record update has been made, a feed tracked update about the record update can then automatically be sent (e.g. in a feed) to anyone subscribing to the opportunity or to the user. Thus, the user does not need to contact a manager regarding the change in the opportunity, since the feed tracked update about the update is sent via a feed right to the manager's feed page (or other page).
Next, mechanisms and methods for providing systems implementing enterprise level social and business information networking will be described with reference to example embodiments. First, an overview of an example database system is described, and then examples of tracking events for a record, actions of a user, and messages about a user or record are described. Various embodiments about the data structure of feeds, customizing feeds, user selection of records and users to follow, generating feeds, and displaying feeds are also described.
II. System Overview
 FIG. 1A illustrates a block diagram of an environment 10 wherein an on-demand database service might be used. Environment 10 may include user systems 12, network 14, system 16, processor system 17, application platform 18, network interface 20, tenant data storage 22, system data storage 24, program code 26, and process space 28. In other embodiments, environment 10 may not have all of the components listed and/or may have other elements instead of, or in addition to, those listed above.
Environment 10 is an environment in which an on-demand database service exists. User system 12 may be any machine or system that is used by a user to access a database user system. For example, any of user systems 12 can be a handheld computing device, a mobile phone, a laptop computer, a work station, and/or a network of computing devices. As illustrated in FIG. 1A (and in more detail in FIG. 1B) user systems 12 might interact via a network 14 with an on-demand database service, which is system 16.
An on-demand database service, such as system 16, is a database system that is made available to outside users that do not need to necessarily be concerned with building and/or maintaining the database system, but instead may be available for their use when the users need the database system (e.g., on the demand of the users). Some on-demand database services may store information from one or more tenants stored into tables of a common database image to form a multi-tenant database system (MTS). Accordingly, âon-demand database service 16â and âsystem 16â will be used interchangeably herein. A database image may include one or more database objects. A relational database management system (RDBMS) or the equivalent may execute storage and retrieval of information against the database object(s). Application platform 18 may be a framework that allows the applications of system 16 to run, such as the hardware and/or software, e.g., the operating system. In an embodiment, on-demand database service 16 may include an application platform 18 that enables creation, managing and executing one or more applications developed by the provider of the on-demand database service, users accessing the on-demand database service via user systems 12, or third party application developers accessing the on-demand database service via user systems 12.
The users of user systems 12 may differ in their respective capacities, and the capacity of a particular user system 12 might be entirely determined by permissions (permission levels) for the current user. For example, where a salesperson is using a particular user system 12 to interact with system 16, that user system has the capacities allotted to that salesperson. However, while an administrator is using that user system to interact with system 16, that user system has the capacities allotted to that administrator. In systems with a hierarchical role model, users at one permission level may have access to applications, data, and database information accessible by a lower permission level user, but may not have access to certain applications, database information, and data accessible by a user at a higher permission level. Thus, different users will have different capabilities with regard to accessing and modifying application and database information, depending on a user's security or permission level, also called authorization.
Network 14 is any network or combination of networks of devices that communicate with one another. For example, network 14 can be any one or any combination of a LAN (local area network), WAN (wide area network), telephone network, wireless network, point-to-point network, star network, token ring network, hub network, or other appropriate configuration. As the most common type of computer network in current use is a TCP/IP (Transfer Control Protocol and Internet Protocol) network, such as the global internetwork of networks often referred to as the âInternetâ with a capital âI,â that network will be used in many of the examples herein. However, it should be understood that the networks that the present embodiments might use are not so limited, although TCP/IP is a frequently implemented protocol.
User systems 12 might communicate with system 16 using TCP/IP and, at a higher network level, use other common Internet protocols to communicate, such as HTTP, FTP, AFS, WAP, etc. In an example where HTTP is used, user system 12 might include an HTTP client commonly referred to as a âbrowserâ for sending and receiving HTTP messages to and from an HTTP server at system 16. Such an HTTP server might be implemented as the sole network interface between system 16 and network 14, but other techniques might be used as well or instead. In some implementations, the interface between system 16 and network 14 includes load sharing functionality, such as round-robin HTTP request distributors to balance loads and distribute incoming HTTP requests evenly over a plurality of servers. At least as for the users that are accessing that server, each of the plurality of servers has access to the MTS' data; however, other alternative configurations may be used instead.
In one embodiment, system 16, shown in FIG. 1A, implements a web-based customer relationship management (CRM) system. For example, in one embodiment, system 16 includes application servers configured to implement and execute CRM software applications as well as provide related data, code, forms, webpages and other information to and from user systems 12 and to store to, and retrieve from, a database system related data, objects, and Webpage content. With a multi-tenant system, data for multiple tenants may be stored in the same physical database object, however, tenant data typically is arranged so that data of one tenant is kept logically separate from that of other tenants so that one tenant does not have access to another tenant's data, unless such data is expressly shared. In certain embodiments, system 16 implements applications other than, or in addition to, a CRM application. For example, system 16 may provide tenant access to multiple hosted (standard and custom) applications, including a CRM application. User (or third party developer) applications, which may or may not include CRM, may be supported by the application platform 18, which manages creation, storage of the applications into one or more database objects and executing of the applications in a virtual machine in the process space of the system 16.
One arrangement for elements of system 16 is shown in FIG. 1A, including a network interface 20, application platform 18, tenant data storage 22 for tenant data 23, system data storage 24 for system data 25 accessible to system 16 and possibly multiple tenants, program code 26 for implementing various functions of system 16, and a process space 28 for executing MTS system processes and tenant-specific processes, such as running applications as part of an application hosting service. Additional processes that may execute on system 16 include database indexing processes.
Several elements in the system shown in FIG. 1A include conventional, well-known elements that are explained only briefly here. For example, each user system 12 could include a desktop personal computer, workstation, laptop, PDA, cell phone, or any wireless access protocol (WAP) enabled device or any other computing device capable of interfacing directly or indirectly to the Internet or other network connection. User system 12 typically runs an HTTP client, e.g., a browsing program, such as Microsoft's Internet Explorer browser, Netscape's Navigator browser, Opera's browser, or a WAP-enabled browser in the case of a cell phone, PDA or other wireless device, or the like, allowing a user (e.g., subscriber of the multi-tenant database system) of user system 12 to access, process and view information, pages and applications available to it from system 16 over network 14. Each user system 12 also typically includes one or more user interface devices, such as a keyboard, a mouse, trackball, touch pad, touch screen, pen or the like, for interacting with a graphical user interface (GUI) provided by the browser on a display (e.g., a monitor screen, LCD display, etc.) in conjunction with pages, forms, applications and other information provided by system 16 or other systems or servers. For example, the user interface device can be used to access data and applications hosted by system 16, and to perform searches on stored data, and otherwise allow a user to interact with various GUI pages that may be presented to a user. As discussed above, embodiments are suitable for use with the Internet, which refers to a specific global internetwork of networks. However, it should be understood that other networks can be used instead of the Internet, such as an intranet, an extranet, a virtual private network (VPN), a non-TCP/IP based network, any LAN or WAN or the like.
According to one embodiment, each user system 12 and all of its components are operator configurable using applications, such as a browser, including computer code run using a central processing unit such as an Intel PentiumÂ® processor or the like. Similarly, system 16 (and additional instances of an MTS, where more than one is present) and all of their components might be operator configurable using application(s) including computer code to run using a central processing unit such as processor system 17, which may include an Intel PentiumÂ® processor or the like, and/or multiple processor units. A computer program product embodiment includes a machine-readable storage medium (media) having instructions stored thereon/in which can be used to program a computer to perform any of the processes of the embodiments described herein. Computer code for operating and configuring system 16 to intercommunicate and to process webpages, applications and other data and media content as described herein are preferably downloaded and stored on a hard disk, but the entire program code, or portions thereof, may also be stored in any other volatile or non-volatile memory medium or device as is well known, such as a ROM or RAM, or provided on any media capable of storing program code, such as any type of rotating media including floppy disks, optical discs, digital versatile disk (DVD), compact disk (CD), microdrive, and magneto-optical disks, and magnetic or optical cards, nanosystems (including molecular memory ICs), or any type of media or device suitable for storing instructions and/or data. Additionally, the entire program code, or portions thereof, may be transmitted and downloaded from a software source over a transmission medium, e.g., over the Internet, or from another server, as is well known, or transmitted over any other conventional network connection as is well known (e.g., extranet, VPN, LAN, etc.) using any communication medium and protocols (e.g., TCP/IP, HTTP, HTTPS, Ethernet, etc.) as are well known. It will also be appreciated that computer code for implementing embodiments of the present invention can be implemented in any programming language that can be executed on a client system and/or server or server system such as, for example, C, C++, HTML, any other markup language, Javaâ¢, JavaScript, ActiveX, any other scripting language, such as VBScript, and many other programming languages as are well known may be used. (Javaâ¢ is a trademark of Sun Microsystems, Inc.).
According to one embodiment, each system 16 is configured to provide webpages, forms, applications, data and media content to user (client) systems 12 to support the access by user systems 12 as tenants of system 16. As such, system 16 provides security mechanisms to keep each tenant's data separate unless the data is shared. If more than one MTS is used, they may be located in close proximity to one another (e.g., in a server farm located in a single building or campus), or they may be distributed at locations remote from one another (e.g., one or more servers located in city A and one or more servers located in city B). As used herein, each MTS could include one or more logically and/or physically connected servers distributed locally or across one or more geographic locations. Additionally, the term âserverâ is meant to include a computer system, including processing hardware and process space(s), and an associated storage system and database application (e.g., OODBMS or RDBMS) as is well known in the art. It should also be understood that âserver systemâ and âserverâ are often used interchangeably herein. Similarly, the database object described herein can be implemented as single databases, a distributed database, a collection of distributed databases, a database with redundant online or offline backups or other redundancies, etc., and might include a distributed database or storage network and associated processing intelligence.
 FIG. 1B also illustrates environment 10. However, in FIG. 1B elements of system 16 and various interconnections in an embodiment are further illustrated. FIG. 1B shows that user system 12 may include processor system 12A, memory system 12B, input system 12C, and output system 12D. FIG. 1B shows network 14 and system 16. FIG. 1B also shows that system 16 may include tenant data storage 22, tenant data 23, system data storage 24, system data 25, User Interface (UI) 30, Application Program Interface (API) 32, PL/SOQL 34, save routines 36, application setup mechanism 38, applications servers 1001-100N, system process space 102, tenant process spaces 104, tenant management process space 110, tenant storage area 112, user storage 114, and application metadata 116. In other embodiments, environment 10 may not have the same elements as those listed above and/or may have other elements instead of, or in addition to, those listed above.
User system 12, network 14, system 16, tenant data storage 22, and system data storage 24 were discussed above in FIG. 1A. Regarding user system 12, processor system 12A may be any combination of one or more processors. Memory system 12B may be any combination of one or more memory devices, short term, and/or long term memory. Input system 12C may be any combination of input devices, such as one or more keyboards, mice, trackballs, scanners, cameras, and/or interfaces to networks. Output system 12D may be any combination of output devices, such as one or more monitors, printers, and/or interfaces to networks. As shown by FIG. 1B, system 16 may include a network interface 20 (of FIG. 1A) implemented as a set of HTTP application servers 100, an application platform 18, tenant data storage 22, and system data storage 24. Also shown is system process space 102, including individual tenant process spaces 104 and a tenant management process space 110. Each application server 100 may be configured to tenant data storage 22 and the tenant data 23 therein, and system data storage 24 and the system data 25 therein to serve requests of user systems 12. The tenant data 23 might be divided into individual tenant storage areas 112, which can be either a physical arrangement and/or a logical arrangement of data. Within each tenant storage area 112, user storage 114 and application metadata 116 might be similarly allocated for each user. For example, a copy of a user's most recently used (MRU) items might be stored to user storage 114. Similarly, a copy of MRU items for an entire organization that is a tenant might be stored to tenant storage area 112. A UI 30 provides a user interface and an API 32 provides an application programmer interface to system 16 resident processes to users and/or developers at user systems 12. The tenant data and the system data may be stored in various databases, such as one or more Oracle| databases.
Application platform 18 includes an application setup mechanism 38 that supports application developers' creation and management of applications, which may be saved as metadata into tenant data storage 22 by save routines 36 for execution by subscribers as one or more tenant process spaces 104 managed by tenant management process 110 for example. Invocations to such applications may be coded using PL/SOQL 34 that provides a programming language style interface extension to API 32. A detailed description of some PL/SOQL language embodiments is discussed in commonly owned U.S. Provisional Patent Application 60/828,192 entitled, PROGRAMMING LANGUAGE METHOD AND SYSTEM FOR EXTENDING APIS TO EXECUTE IN CONJUNCTION WITH DATABASE APIS, by Craig Weissman, filed Oct. 4, 2006, which is hereby incorporated by reference in its entirety and for all purposes. Invocations to applications may be detected by one or more system processes, which manage retrieving application metadata 116 for the subscriber making the invocation and executing the metadata as an application in a virtual machine.
Each application server 100 may be communicably coupled to database systems, e.g., having access to system data 25 and tenant data 23, via a different network connection. For example, one application server 1001 might be coupled via the network 14 (e.g., the Internet), another application server 100N-1 might be coupled via a direct network link, and another application server 100N might be coupled by yet a different network connection. Transfer Control Protocol and Internet Protocol (TCP/IP) are typical protocols for communicating between application servers 100 and the database system. However, it will be apparent to one skilled in the art that other transport protocols may be used to optimize the system depending on the network interconnect used.
In certain embodiments, each application server 100 is configured to handle requests for any user associated with any organization that is a tenant. Because it is desirable to be able to add and remove application servers from the server pool at any time for any reason, there is preferably no server affinity for a user and/or organization to a specific application server 100. In one embodiment, therefore, an interface system implementing a load balancing function (e.g., an F5 Big-IP load balancer) is communicably coupled between the application servers 100 and the user systems 12 to distribute requests to the application servers 100. In one embodiment, the load balancer uses a least connections algorithm to route user requests to the application servers 100. Other examples of load balancing algorithms, such as round robin and observed response time, also can be used. For example, in certain embodiments, three consecutive requests from the same user could hit three different application servers 100, and three requests from different users could hit the same application server 100. In this manner, system 16 is multi-tenant, wherein system 16 handles storage of, and access to, different objects, data and applications across disparate users and organizations.
As an example of storage, one tenant might be a company that employs a sales force where each salesperson uses system 16 to manage their sales process. Thus, a user might maintain contact data, leads data, customer follow-up data, performance data, goals and progress data, etc., all applicable to that user's personal sales process (e.g., in tenant data storage 22). In an example of a MTS arrangement, since all of the data and the applications to access, view, modify, report, transmit, calculate, etc., can be maintained and accessed by a user system having nothing more than network access, the user can manage his or her sales efforts and cycles from any of many different user systems. For example, if a salesperson is visiting a customer and the customer has Internet access in their lobby, the salesperson can obtain critical updates as to that customer while waiting for the customer to arrive in the lobby.
While each user's data might be separate from other users' data regardless of the employers of each user, some data might be organization-wide data shared or accessible by a plurality of users or all of the users for a given organization that is a tenant. Thus, there might be some data structures managed by system 16 that are allocated at the tenant level while other data structures might be managed at the user level. Because an MTS might support multiple tenants including possible competitors, the MTS should have security protocols that keep data, applications, and application use separate. Also, because many tenants may opt for access to an MTS rather than maintain their own system, redundancy, up-time, and backup are additional functions that may be implemented in the MTS. In addition to user-specific data and tenant-specific data, system 16 might also maintain system level data usable by multiple tenants or other data. Such system level data might include industry reports, news, postings, and the like that are sharable among tenants.
In certain embodiments, user systems 12 (which may be client systems) communicate with application servers 100 to request and update system-level and tenant-level data from system 16 that may require sending one or more queries to tenant data storage 22 and/or system data storage 24. System 16 (e.g., an application server 100 in system 16) automatically generates one or more SQL statements (e.g., one or more SQL queries) that are designed to access the desired information. System data storage 24 may generate query plans to access the requested data from the database.
Each database can generally be viewed as a collection of objects, such as a set of logical tables, containing data fitted into predefined categories. A âtableâ is one representation of a data object, and may be used herein to simplify the conceptual description of objects and custom objects according to embodiments of the present invention. It should be understood that âtableâ and âobjectâ may be used interchangeably herein. Each table generally contains one or more data categories logically arranged as columns or fields in a viewable schema. Each row or record of a table contains an instance of data for each category defined by the fields. For example, a CRM database may include a table that describes a customer with fields for basic contact information such as name, address, phone number, fax number, etc. Another table might describe a purchase order, including fields for information such as customer, product, sale price, date, etc. In some multi-tenant database systems, standard entity tables might be provided for use by all tenants. For CRM database applications, such standard entities might include tables for Account, Contact, Lead, and Opportunity data, each containing pre-defined fields. It should be understood that the word âentityâ may also be used interchangeably herein with âobjectâ and âtableâ.
In some multi-tenant database systems, tenants may be allowed to create and store custom objects, or they may be allowed to customize standard entities or objects, for example by creating custom fields for standard objects, including custom index fields. U.S. Pat. No. 7,779,039 by Weissman et al., filed Apr. 2, 2004, entitled âCustom Entities and Fields in a Multi-Tenant Database Systemâ, and which is hereby incorporated by reference in its entirety and for all purposes, teaches systems and methods for creating custom objects as well as customizing standard objects in a multi-tenant database system. In certain embodiments, for example, all custom entity data rows are stored in a single multi-tenant physical table, which may contain multiple logical tables per organization. It is transparent to customers that their multiple âtablesâ are in fact stored in one large table or that their data may be stored in the same table as the data of other customers.
 FIG. 2A shows a system diagram 200 illustrating architectural components of an on-demand service environment, in accordance with one embodiment.
A client machine located in the cloud 204 (or Internet) may communicate with the on-demand service environment via one or more edge routers 208 and 212. The edge routers may communicate with one or more core switches 220 and 224 via firewall 216. The core switches may communicate with a load balancer 228, which may distribute server load over different pods, such as the pods 240 and 244. The pods 240 and 244, which may each include one or more servers and/or other computing resources, may perform data processing and other operations used to provide on-demand services. Communication with the pods may be conducted via pod switches 232 and 236. Components of the on-demand service environment may communicate with a database storage system 256 via a database firewall 248 and a database switch 252.
As shown in FIGS. 2A and 2B, accessing an on-demand service environment may involve communications transmitted among a variety of different hardware and/or software components. Further, the on-demand service environment 200 is a simplified representation of an actual on-demand service environment. For example, while only one or two devices of each type are shown in FIGS. 2A and 2B, some embodiments of an on-demand service environment may include anywhere from one to many devices of each type. Also, the on-demand service environment need not include each device shown in FIGS. 2A and 2B, or may include additional devices not shown in FIGS. 2A and 2B.
Moreover, one or more of the devices in the on-demand service environment 200 may be implemented on the same physical device or on different hardware. Some devices may be implemented using hardware or a combination of hardware and software. Thus, terms such as âdata processing apparatus,â âmachine,â âserverâ and âdeviceâ as used herein are not limited to a single hardware device, but rather include any hardware and software configured to provide the described functionality.
The cloud 204 is intended to refer to a data network or plurality of data networks, often including the Internet. Client machines located in the cloud 204 may communicate with the on-demand service environment to access services provided by the on-demand service environment. For example, client machines may access the on-demand service environment to retrieve, store, edit, and/or process information.
In some embodiments, the edge routers 208 and 212 route packets between the cloud 204 and other components of the on-demand service environment 200. The edge routers 208 and 212 may employ the Border Gateway Protocol (BGP). The BGP is the core routing protocol of the Internet. The edge routers 208 and 212 may maintain a table of IP networks or âprefixesâ which designate network reachability among autonomous systems on the Internet.
In one or more embodiments, the firewall 216 may protect the inner components of the on-demand service environment 200 from Internet traffic. The firewall 216 may block, permit, or deny access to the inner components of the on-demand service environment 200 based upon a set of rules and other criteria. The firewall 216 may act as one or more of a packet filter, an application gateway, a stateful filter, a proxy server, or any other type of firewall.
In some embodiments, the core switches 220 and 224 are high-capacity switches that transfer packets within the on-demand service environment 200. The core switches 220 and 224 may be configured as network bridges that quickly route data between different components within the on-demand service environment. In some embodiments, the use of two or more core switches 220 and 224 may provide redundancy and/or reduced latency.
In some embodiments, the pods 240 and 244 may perform the core data processing and service functions provided by the on-demand service environment. Each pod may include various types of hardware and/or software computing resources. An example of the pod architecture is discussed in greater detail with reference to FIG. 2B.
In some embodiments, communication between the pods 240 and 244 may be conducted via the pod switches 232 and 236. The pod switches 232 and 236 may facilitate communication between the pods 240 and 244 and client machines located in the cloud 204, for example via core switches 220 and 224. Also, the pod switches 232 and 236 may facilitate communication between the pods 240 and 244 and the database storage 256.
In some embodiments, the load balancer 228 may distribute workload between the pods 240 and 244. Balancing the on-demand service requests between the pods may assist in improving the use of resources, increasing throughput, reducing response times, and/or reducing overhead. The load balancer 228 may include multilayer switches to analyze and forward traffic.
In some embodiments, access to the database storage 256 may be guarded by a database firewall 248. The database firewall 248 may act as a computer application firewall operating at the database application layer of a protocol stack. The database firewall 248 may protect the database storage 256 from application attacks such as structure query language (SQL) injection, database rootkits, and unauthorized information disclosure.
In some embodiments, the database firewall 248 may include a host using one or more forms of reverse proxy services to proxy traffic before passing it to a gateway router. The database firewall 248 may inspect the contents of database traffic and block certain content or database requests. The database firewall 248 may work on the SQL application level atop the TCP/IP stack, managing applications' connection to the database or SQL management interfaces as well as intercepting and enforcing packets traveling to or from a database network or application interface.
In some embodiments, communication with the database storage system 256 may be conducted via the database switch 252. The multi-tenant database system 256 may include more than one hardware and/or software components for handling database queries. Accordingly, the database switch 252 may direct database queries transmitted by other components of the on-demand service environment (e.g., the pods 240 and 244) to the correct components within the database storage system 256.
In some embodiments, the database storage system 256 is an on-demand database system shared by many different organizations. The on-demand database system may employ a multi-tenant approach, a virtualized approach, or any other type of database approach. An on-demand database system is discussed in greater detail with reference to FIGS. 1A and 1B.
 FIG. 2B shows a system diagram illustrating the architecture of the pod 244, in accordance with one embodiment. The pod 244 may be used to render services to a user of the on-demand service environment 200.
In some embodiments, each pod may include a variety of servers and/or other systems. The pod 244 includes one or more content batch servers 264, content search servers 268, query servers 272, file force servers 276, access control system (ACS) servers 280, batch servers 284, and app servers 288. Also, the pod 244 includes database instances 290, quick file systems (QFS) 292, and indexers 294. In one or more embodiments, some or all communication between the servers in the pod 244 may be transmitted via the switch 236.
In some embodiments, the application servers 288 may include a hardware and/or software framework dedicated to the execution of procedures (e.g., programs, routines, scripts) for supporting the construction of applications provided by the on-demand service environment 200 via the pod 244. Some such procedures may include operations for providing the services described herein, such as performing the methods/processes described below with reference to FIGS. 15-17. In alternative embodiments, two or more app servers 288 may be included and cooperate to perform such methods, or one or more other servers in FIG. 2B can be configured to perform the disclosed methods described below.
The content batch servers 264 may requests internal to the pod. These requests may be long-running and/or not tied to a particular customer. For example, the content batch servers 264 may handle requests related to log mining, cleanup work, and maintenance tasks.
The content search servers 268 may provide query and indexer functions. For example, the functions provided by the content search servers 268 may allow users to search through content stored in the on-demand service environment.
The Fileforce servers 276 may manage requests information stored in the Fileforce storage 278. The Fileforce storage 278 may store information such as documents, images, and basic large objects (BLOBs). By managing requests for information using the Fileforce servers 276, the image footprint on the database may be reduced.
The query servers 272 may be used to retrieve information from one or more file systems. For example, the query system 272 may receive requests for information from the app servers 288 and then transmit information queries to the NFS 296 located outside the pod.
The pod 244 may share a database instance 290 configured as a multi-tenant environment in which different organizations share access to the same database. Additionally, services rendered by the pod 244 may require various hardware and/or software resources. In some embodiments, the ACS servers 280 may control access to data, hardware resources, or software resources.
In some embodiments, the batch servers 284 may process batch jobs, which are used to run tasks at specified times. Thus, the batch servers 284 may transmit instructions to other servers, such as the app servers 288, to trigger the batch jobs.
In some embodiments, the QFS 292 may be an open source file system available from Sun MicrosystemsÂ® of Santa Clara, Calif. The QFS may serve as a rapid-access file system for storing and accessing information available within the pod 244. The QFS 292 may support some volume management capabilities, allowing many disks to be grouped together into a file system. File system metadata can be kept on a separate set of disks, which may be useful for streaming applications where long disk seeks cannot be tolerated. Thus, the QFS system may communicate with one or more content search servers 268 and/or indexers 294 to identify, retrieve, move, and/or update data stored in the network file systems 296 and/or other storage systems.
In some embodiments, one or more query servers 272 may communicate with the NFS 296 to retrieve and/or update information stored outside of the pod 244. The NFS 296 may allow servers located in the pod 244 to access information to access files over a network in a manner similar to how local storage is accessed.
In some embodiments, queries from the query servers 222 may be transmitted to the NFS 296 via the load balancer 220, which may distribute resource requests over various resources available in the on-demand service environment. The NFS 296 may also communicate with the QFS 292 to update the information stored on the NFS 296 and/or to provide information to the QFS 292 for use by servers located within the pod 244.
In some embodiments, the pod may include one or more database instances 290. The database instance 290 may transmit information to the QFS 292. When information is transmitted to the QFS, it may be available for use by servers within the pod 244 without requiring an additional database call.
In some embodiments, database information may be transmitted to the indexer 294. Indexer 294 may provide an index of information available in the database 290 and/or QFS 292. The index information may be provided to file force servers 276 and/or the QFS 292.
III. Tracking Updates to a Record Stored in a Database
As multiple users might be able to change the data of a record, it can be useful for certain users to be notified when a record is updated. Also, even if a user does not have authority to change a record, the user still might want to know when there is an update. For example, a vendor may negotiate a new price with a salesperson of company X, where the salesperson is a user associated with tenant X. As part of creating a new invoice or for accounting purposes, the salesperson can change the price saved in the database. It may be important for co-workers to know that the price has changed. The salesperson could send an e-mail to certain people, but this is onerous and the salesperson might not e-mail all of the people who need to know or want to know. Accordingly, embodiments can inform others (e.g. co-workers) who want to know about an update to a record automatically.
 FIG. 3 is a flowchart of a method 300 for tracking updates to a record stored in a database system according to embodiments. In some embodiments, method 300 (and other methods described herein) may be implemented at least partially with multi-tenant database system 16, e.g., by one or more processors configured to receive or retrieve information, process the information, store results, and the transmit the results. In other embodiments, method 300 may be implemented at least partially with a single tenant database system. In various embodiments, steps may be omitted, combined, or split into additional steps for method 300, as well as for other methods described herein.
In step 310, the database system receives a request to update a first record. In one embodiment, the request is received from a first user. For example, a user may be accessing a page associated with the first record, and may change a displayed field and hit save. In another embodiment, the database system can automatically create the request. For instance, the database system can create the request in response to another event, e.g., a request to change a field could be sent periodically at a particular date and/or time of day, or a change to another field or object. The database system can obtain a new value based on other fields of a record and/or based on parameters in the system.
The request for the update of a field of a record is an example of an event associated with the first record for which a feed tracked update may be created. In other embodiments, the database system can identify other events besides updates to fields of a record. For example, an event can be a submission of approval to change a field. Such an event can also have an associated field (e.g., a field showing a status of whether a change has been submitted). Other examples of events can include creation of a record, deletion of a record, converting a record from one type to another (e.g. converting a lead to an opportunity), closing a record (e.g. a case type record), and potentially any state change of a recordâany of which could include a field change associated with the state change. Any of these events update the record whether by changing a field of the record, a state of the record, or some other characteristic or property of the record. In one embodiment, a list of supported events for creating a feed tracked update can be maintained within the database system, e.g., at a server or in a database.
In step 320, the database system writes new data to the first record. In one embodiment, the new data may include a new value that replaces old data. For example, a field is updated with a new value. In another embodiment, the new data can be a value for a field that did not contain data before. In yet another embodiment, the new data could be a flag, e.g., for a status of the record, which can be stored as a field of the record.
In some embodiments, a âfieldâ can also include records that are child objects of the first record. A child object itself can include further fields. Thus, if a field of a child object is updated with a new value, the parent record also can be considered to have a field changed. In one example, a field could be a list of related child objects, also called a related list.
In step 330, a feed tracked update is generated about the update to the record. In one embodiment, the feed tracked update is created in parts for assembling later into a display version. For example, event entries can be created and tracked in one table, and changed field entries can be tracked in another table that is cross-referenced with the first table. More specifics of such embodiments are provided later, e.g., with respect to FIG. 9A. In another embodiment, the feed tracked update is automatically generated by the database system. The feed tracked update can convey in words that the first record has been updated and provide details about what was updated in the record and who performed the update. In some embodiments, a feed tracked update is generated for only certain types of event and/or updates associated with the first record.
In one embodiment, a tenant (e.g. through an administrator) can configure the database system to create (enable) feed tracked updates only for certain types of records. For example, an administrator can specify that records of type Account and Opportunity are enabled. When an update (or other event) is received for the enabled record type, then a feed tracked update would be generated. In another embodiment, a tenant can also specify the fields of a record whose changes are to be tracked, and for which feed tracked updates are created. In one aspect, a maximum number of fields can be specified for tracking, and may include custom fields. In one implementation, the type of change can also be specified, for example, that the value change of a field is required to be larger than a threshold (e.g. an absolute amount or a percentage change). In yet another embodiment, a tenant can specify which events are to cause a generation of a feed tracked update. Also, in one implementation, individual users can specify configurations specific to them, which can create custom feeds as described in more detail below.
In one embodiment, changes to fields of a child object are not tracked to create feed tracked updates for the parent record. In another embodiment, the changes to fields of a child object can be tracked to create feed tracked updates for the parent record. For example, a child object of the parent type can be specified for tracking, and certain fields of the child object can be specified for tracking. As another example, if the child object is of a type specified for tracking, then a tracked change for the child object is propagated to parent records of the child object.
In step 340, the feed tracked update is added to a feed for the first record. In one embodiment, adding the feed tracked update to a feed can include adding events to a table (which may be specific to a record or be for all or a group of objects), where a display version of a feed tracked update can be performed dynamically when a user requests a feed for the first record. In another embodiment, a display version of a feed tracked update can be added when a record feed is stored and maintained for a record. As mentioned above, a feed may be maintained for only certain records. In one implementation, the feed of a record can be stored in the database associated with the feed. For example, the feed can be stored as a field (e.g. as a child object) of the record. Such a field can store a pointer to the text to be displayed for the feed tracked update.
In some embodiments, only the current feed tracked update (or other current feed item) may be kept or temporarily stored, e.g., in some temporary memory structure. For example, a feed tracked update for only a most recent change to any particular field is kept. In other embodiments, many previous feed tracked updates may be kept in the feed. A time and/or date for each feed tracked update can be tracked. Herein, a feed of a record is also referred to as an entity feed, as a record is an instance of a particular entity object of the database.
In step 350, followers of the first record can be identified. A follower is a user following (subscribing to a feed of) the first record. In one embodiment, when a user requests a feed of a particular record such an identification need not be done. In another embodiment where a record feed is pushed to a user (e.g. as part of a news feed), then the user can be identified as a follower of the first record. Accordingly, this step can be the identification of records and other objects being followed by a particular user.
In one embodiment, the database system can store a list of the followers for a particular record. In various implementations, the list can be stored with the first record or associated with the record using an identifier (e.g. a pointer) to retrieve the list. For example, the list can be stored in a field of the first record. In another embodiment, a list of the records that a user is following is used. In one implementation, the database system can have a routine that runs for each user, where the routine polls the records in the list to determine if a new feed tracked update has been added to a feed of the record. In another implementation, the routine for the user can be running at least partially on a user device, which contacts the database to perform the polling.
In step 360, the feed tracked update is added to a feed of each follower. In one embodiment, the feed tracked update is pushed to the feed of a user, e.g., by a routine that determines the followers for the record from a list associated with the record. In another embodiment, the feed tracked update is pulled to a feed, e.g., by a user device. This pulling may occur when a user requests the feed, as occurs in step 370. Thus, these actions may occur in a different order. The creation of the feed for a pull may be a dynamic creation that identifies records being followed by the requesting user, generates the display version of relevant feed tracked updates from stored information (e.g. event and field change), and adds the feed tracked updates into the feed. A feed of feed tracked updates of records and other objects that a user is following is also called a news feed.
In yet another embodiment, the feed tracked update could be sent as an e-mail to the follower, instead of in a feed. In one implementation, e-mail alerts for events can enable people to be e-mailed when certain events occur. In another implementation, e-mails can be sent when there are posts on a user profile and posts on entities to which the user subscribes. In one implementation, a user can turn on/off email alerts for all or some events. In an embodiment, a user can specify what kind of feed tracked updates to receive about a record that the user is following. For example, a user can choose to only receive feed tracked updates about certain fields of a record that the user is following, and potentially about what kind of update was performed (e.g. a new value input into a specified field, or the creation of a new field).
In step 370, a follower can access his/her news feed to see the feed tracked update. In one embodiment, the user has just one news feed for all of the records that the user is following. In one aspect, a user can access his/her own feed by selecting a particular tab or other object on a page of an interface to the database system. Once selected the feed can be provided as a list, e.g., with an identifier (e.g. a time) or including some or all of the text of the feed tracked update. In another embodiment, the user can specify how the feed tracked updates are to be displayed and/or sent to the user. For example, a user can specify a font for the text, a location of where the feed can be selected and displayed, amount of text to be displayed, and other text or symbols to be displayed (e.g. importance flags).
 FIG. 4 is a block diagram 400 of components of a database system performing a method for tracking an update to a record according to embodiments. Block diagram 400 can perform embodiments of method 300, as well as embodiments of other method described herein.
A first user 405 sends a request 1 to update record 425 in database system 416. Although an update request is described, other events that are being tracked are equally applicable. In various embodiments, the request 1 can be sent via a user interface (e.g. 30 of FIG. 1B) or an application program interface (e.g. API 32). An I/O port 420 can accommodate the signals of request 1 via any input interface, and send the signals to one or more processors 417. The processor 417 can analyze the request and determine actions to be performed. Herein, any reference to a processor 417 can refer to a specific processor or any set of processors in database system 416, which can be collectively referred to as processor 417.
Processor 417 can determine an identifier for record 425, and send commands 2 with the new data to record database 412 to update record 425. In one embodiment, record database 412 is where tenant data 112 is stored. The request 1 and new data commands 2 can be encapsulated in a single write transaction sent to record database 412. In one embodiment, multiple changes to records in the database can be made in a single write transaction.
Processor 417 can also analyze request 1 to determine whether a feed tracked update is to be created, which at this point may include determining whether the event (e.g. a change to a particular field) is to be tracked. This determination can be based on an interaction (i.e. an exchange of data) with record database 412 and/or other databases, or based on information stored locally (e.g. in cache or RAM) at processor 417. In one embodiment, a list of record types that are being tracked can be stored. The list may be different for each tenant, e.g. as each tenant may configure the database system to their own specifications. Thus, if the record 425 is of a type not being tracked, then the determination of whether to create a feed tracked update can stop there.
The same list or a second list (which can be stored in a same location or a different location) can also include the fields and/or events that are tracked for the record types in the first list. This list can be searched to determine if the event is being tracked. A list may also contain information having the granularity of listing specific records that are to be tracked (e.g. if a tenant can specify the particular records to be tracked, as opposed to just type).
As an example, processor 417 may obtain an identifier associated with record 425 (e.g. obtained from request 1 or database 412), potentially along with a tenant identifier, and cross-reference the identifier with a list of records for which feed tracked updates are to be created. Specifically, the record identifier can be used to determine the record type and a list of tracked types can be searched for a match. The specific record may also be checked if such individual record tracking was enabled. The name of the field to be changed can also be used to search a list of tracking-enabled fields. Other criteria besides field and events can be used to determine whether a feed tracked update is created, e.g., type of change in the field. If a feed tracked update is to be generated, processor 417 can then generate the feed tracked update.
In some embodiments, a feed tracked update is created dynamically when a feed (e.g. the entity feed of record 425) is requested. Thus, in one implementation, a feed tracked update can be created when a user requests the entity feed for record 425. In this embodiment, the feed tracked update may be created (e.g. assembled), including re-created, each time the entity feed is to be displayed to any user. In one implementation, one or more hifeed tracked update tables can keep track of previous events so that the feed tracked update can be re-created.
In another embodiment, a feed tracked update can be created at the time the event occurs, and the feed tracked update can be added to a list of feed items. The list of feed items may be specific to record 425, or may be an aggregate of feed items including feed items for many records. Such an aggregate list can include a record identifier so that the feed items for the entity feed of record 425 can be easily retrieved. For example, after the feed tracked update has been generated, processor 417 can add the new feed tracked update 3 to a feed of record 425. As mentioned above, in one embodiment, the feed can be stored in a field (e.g. as a child object) of record 425. In another embodiment, the feed can be stored in another location or in another database, but with a link (e.g. a connecting identifier) to record 425. The feed can be organized in various ways, e.g., as a linked list, an array, or other data structure.
A second user 430 can access the new feed tracked update 3 in various ways. In one embodiment, second user 430 can send a request 4 for the record feed. For example, second user 430 can access a home page (detail page) of the record 425 (e.g. with a query or by browsing), and the feed can be obtained through a tab, button, or other activation object on the page. The feed can be displayed on the screen or downloaded.
In another embodiment, processor 417 can add the new feed tracked update in a step 5 to a feed (e.g. a news feed) of a user that is following record 425. In one implementation, processor 417 can determine each of the followers of record 425 by accessing a list of the users that have been registered as followers. This determination can be done for each new event (e.g. update 1). In another implementation, processor 417 can poll (e.g. with a query) the records that second user 430 is following to determine when new feed tracked updates (or other feed items) are available. Processor 417 can use a follower profile 435 of second user 430, which can contain a list of the records that the second user 430 is following. Such a list can be contained in other parts of the database as well. Second user 430 can then send a request 6 to his/her profile 435 to obtain a feed, which contains the new feed tracked update. The user's profile 435 can be stored in a profile database 414, which can be the same or different than database 412.
In some embodiments, a user can define a news feed to include new feed tracked updates from various records, which may be limited to a maximum number. In one embodiment, each user has one news feed. In another embodiment, the follower profile 435 can include the specifications of each of the records to be followed (with the criteria for what feed tracked updates are to be provided and how they are displayed), as well as the feed.
Some embodiments can provide various types of record (entity) feeds. Entity Feeds can exist for records like Account, Opportunity, Case, and Contact. An entity feed can tell a user about the actions that people have taken on that particular record or on one its related records. The entity feed can include who made the action, which field was changed, and the old and new values. In one embodiment, entity feeds can exist on all supported records as a list that is linked to the specific record. For example, a feed could be stored in a field that allows lists (e.g. linked lists) or as a child object.
IV. Tracking Actions of a User
In addition to knowing about events associated with a particular record, it can be helpful for a user to know what a particular user is doing. In particular, it might be nice to know what the user is doing without the user having to generate the feed tracked update (e.g. a user submitting a synopsis of what the user has done). Accordingly, embodiments can automatically track actions of a user that trigger events, and feed tracked updates can be generated for certain events.
 FIG. 5 is a flowchart of a method 500 for tracking actions of a user of a database system according to embodiments. Method 500 may be performed in addition to method 300. The methods of implementing method 300, including order of steps, can also be applied to method 500 and other methods described herein. Thus, a feed can be composed of changes to a record and actions of users.
In step 510, a database system (e.g. 16) identifies an action of a first user. In one embodiment, the action triggers an event, and the event is identified. For example, the action of a user requesting an update to a record can be identified, where the event is receiving a request or is the resulting update of a record. The action may thus be defined by the resulting event. In another embodiment, only certain types of actions (events) are identified. Which actions are identified can be set as a default or can be configurable by a tenant, or even configurable at a user level. In this way, processing effort can be reduced since only some actions are identified.
In step 520, it is determined whether the event qualifies for a feed tracked update. In one embodiment, a predefined list of events (e.g. as mentioned herein) can be created so that only certain actions are identified. In one embodiment, an administrator (or other user) of a tenant can specify the type of actions (events) for which a feed tracked update is to be generated. This step may also be performed for method 300.
In step 530, a feed tracked update is generated about the action. In an example where the action is an update of a record, the feed tracked update can be similar or the same as the feed tracked update created for the record. The description can be altered though to focus on the user as opposed to the record. For example, âJohn D. has closed a new opportunity for account XYZâ as opposed to âan opportunity has been closed for account XYZ.â
In step 540, the feed tracked update is added to a profile feed of the first user. In one embodiment, a feed for a particular user can be accessed on a page of the user's profile, in a similar manner as a record feed can be accessed on a detail page of the record. In another embodiment, the first user may not have a profile feed and the feed tracked update may just be stored temporarily before proceeding. A profile feed of a user can be stored associated with the user's profile. This profile feed can be added to a news feed of another user.
In step 550, followers of the first user are identified. In one embodiment, a user can specify which type of actions other users can follow. Similarly, in one implementation, a follower can select what actions by a user the follower wants to follow. In an embodiment where different followers follow different types of actions, which users are followers of that user and the particular action can be identified, e.g., using various lists that track what actions and criteria are being followed by a particular user. In various embodiments, the followers of the first user can be identified in a similar manner as followers of a record, as described above for step 350.
In step 560, the feed tracked update is added to a news feed of each follower of the first user. The feed tracked update can be added in a similar manner as the feed items for a record feed. The news feed can contain feed tracked updates both about users and records. In another embodiment, a user can specify what kind of feed tracked updates to receive about a user that the user is following. For example, a user could specify feed tracked updates with particular keywords, of certain types of records, of records owned or created by certain users, particular fields, and other criteria as mentioned herein.
In step 570, a follower accesses the news feed and sees the feed tracked update. In one embodiment, the user has just one news feed for all of the records that the user is following. In another embodiment, a user can access his/her own feed (i.e. feed about his/her own actions) by selecting a particular tab or other object on a page of an interface to the database system. Thus, a feed can include feed tracked updates about what other users are doing in the database system. When a user becomes aware of a relevant action of another user, the user can contact the co-worker, thereby fostering teamwork.
V. Generation of a Feed Tracked Update
As described above, some embodiments can generate text describing events (e.g. updates) that have occurred for a record and actions by a user that trigger an event. A database system can be configured to generate the feed tracked updates for various events in various ways.
A. Which Events to Generate a Feed Tracked Update
In a database system, there are various events that can be detected. However, the operator of the database system and/or a tenant may not want to detect every possible event as this could be costly with regards to performance. Accordingly, the operator and/or the tenant can configure the database system to only detect certain events. For example, an update of a record may be an event that is to be detected.
Out of the events that are detected, a tenant (including a specific user of the tenant) may not want a feed tracked update about each detected event. For example, all updates to a record may be identified at a first level. Then, based on specifications of an administrator and/or a specific user of a tenant, another level of inquiry can be made as to whether a feed tracked update is to be generated about the detected event. For example, the events that qualify for a feed tracked update can be restricted to changes for only certain fields of the record, which can differ depending on which user is receiving the feed. In one embodiment, a database system can track whether an event qualifies for a feed tracked update for any user, and once the feed tracked update is generated, it can be determined who is to receive the feed tracked update.
Supported events (events for which a feed tracked update is generated) can include actions for standard fields, custom fields, and standard related lists. Regarding standard fields, for the entity feed and the profile feed, a standard field update can trigger a feed tracked update to be published to that feed. In one embodiment, which standard field can create a feed tracked update can be set by an administrator to be the same for every user. In another embodiment, a user can set which standard fields create a feed tracked update for that user's news feed. Custom fields can be treated the same or differently than standard fields.
The generation of a feed item can also depend on a relationship of an object to other objects (e.g. parent-child relationships). For example, if a child object is updated, a feed tracked update may be written to a feed of a parent of the child object. The level of relationship can be configured, e.g., only 1 level of separation (i.e. no grandparent-grandchild relationship). Also, in one embodiment, a feed tracked update is generated only for objects above the objects being updated, i.e., a feed tracked update is not written for a child when the parent is updated.
In some embodiments, for related lists of a record, a feed tracked update is written to its parent record (1 level only) when the related list item is added, and not when the list item is changed or deleted. For example: user A added a new opportunity XYZ for account ABC. In this manner, entity feeds can be controlled so as not to be cluttered with feed tracked updates about changes to their related items. Any changes to the related list item can be tracked on their own entity feed, if that related list item has a feed on it. In this embodiment, if a user wants to see a feed of the related list item then the user can subscribe to it. Such a subscription might be when a user cares about a specific opportunity related to a specific account. A user can also browse to that object's entity feed. Other embodiments can create a feed tracked update when a related entity is changed or deleted.
In one embodiment, an administrator (of the system or of a specific tenant) can define which events of which related objects are to have feed tracked updates written about them in a parent record. In another embodiment, a user can define which related object events to show. In one implementation, there are two types of related lists of related objects: first class lookup and second class lookup. Each of the records in the related lists can have a different rule for whether a feed tracked update is generated for a parent record. Each of these related lists can be composed as custom related lists. In various embodiments, a custom related list can be composed of custom objects, the lists can contain a variety of records or items (e.g. not restricted to a particular type of record or item), and can be displayed in a customized manner.
In one embodiment, a first class lookup contains records of a child record that can exist by itself. For example, the contacts on an account exist as a separate record and also as a child record of the account. In another embodiment, a record in a first class lookup can have its own feed, which can be displayed on its detail page.
In one embodiment, a second class lookup can have line items existing only in the context of their parent record (e.g. activities on an opportunity, contact roles on opportunity/contact). In one implementation, the line items are not objects themselves, and thus there is no detail page, and no place to put a feed. In another implementation, a change in a second class lookup can be reported on the feed of the parent.
Some embodiments can also create feed tracked updates for dependent field changes. A dependent field change is a field that changes value when another field changes, and thus the field has a value that is dependent on the value of the other field. For example, a dependent field might be a sum (or other formula) that totals values in other fields, and thus the dependent field would change when one of the fields being summed changes. Accordingly, in one embodiment, a change in one field could create feed tracked updates for multiple fields. In other embodiments, feed tracked updates are not created for dependent fields.
B. How the Feed Tracked Update is Generated
After it is determined that a feed tracked update is going to be generated, some embodiments can also determine how the feed tracked update is generated. In one embodiment, different methods can be used for different events, e.g., in a similar fashion as for the configurability of which events feed tracked updates are generated. A feed tracked update can also include a description of multiple events (e.g. john changed the account status and amount).
In one embodiment, the feed tracked update is a grammatical sentence, thereby being easily understandable by a person. In another embodiment, the feed tracked update provides detailed information about the update. In various examples, an old value and new value for a field may be included in the feed tracked update, an action for the update may be provided (e.g. submitted for approval), and the names of particular users that are responsible for replying or acting on the feed tracked update may be also provided. The feed tracked update can also have a level of importance based on settings chosen by the administrator, a particular user requesting an update, or by a following user who is to receive the feed tracked update, which fields is updated, a percentage of the change in a field, the type of event, or any combination of these factors.
The system may have a set of heuristics for creating a feed tracked update from the event (e.g. a request to update). For example, the subject may be the user, the record, or a field being added or changed. The verb can be based on the action requested by the user, which can be selected from a list of verbs (which may be provided as defaults or input by an administrator of a tenant). In one embodiment, feed tracked updates can be generic containers with formatting restrictions,
As an example of a creation of a new record, âMark Abramowitz created a new Opportunity IBMâ20,000 laptops with Amount as $3.5M and Sam Palmisano as Decision Maker.â This event can be posted to the profile feed for Mark Abramowitz and the entity feed for record of Opportunity for IBMâ20,000 laptops. The pattern can be given by (AgentFullName) created a new (ObjectName)(RecordName) with [(FieldName) as (FieldValue) [,/and]]*[[added/changed/removed] (RelatedListRecordName) [as/to/as] (RelatedListRecordValue) [,/and] ]*. Similar patterns can be formed for a changed field (standard or custom) and an added child record to a related list.
VI. Tracking Commentary from or about a User
Some embodiments can also have a user submit text, instead of the database system generating a feed tracked update. As the text is submitted by users, the text (also referred generally as messages) can be about any topic. Thus, more information than just actions of a user and events of a record can be conveyed. In one embodiment, the messages can be used to ask a question about a particular record, and users following the record can provide responses (comments).
 FIG. 6 is a flowchart of a method 600 for creating a news feed that includes messages associated with a first user according to embodiments. In one embodiment, method 600 can be combined with methods 300 and 500. In one aspect, a message can be associated with the first user when the first user creates the message (e.g. a post or comment about a record or another user). In another aspect, a message can be associated with the first user when the message is about the first user (e.g. posted by another user on the first user's profile feed).
In step 610, database system receives a message (e.g. a post or status) associated with a first user. The message (e.g. a post or status update) can contain text submitted by another user or by the first user. In one embodiment, a post is for a section of the first user's profile where any user can add a post, and where multiple posts can exist. Thus, a post can appear on the first user's profile and can be viewed when the first user's profile is visited. For a message about a record, the post can appear on a detail page of a record. Note the message can appear in other feeds as well. In another embodiment, a status update about the first user can only be added by the first user. In one implementation, a user can only have one status message.
In step 620, the message is added to a profile of the first user. In one implementation, the message can be added to a profile feed of the first user, which is associated (e.g. as a related list) with the first user's profile. In one embodiment, the posts are listed indefinitely. In another embodiment, only the most recent posts (e.g. last 50) are kept in the profile feed. Such embodiments can also be employed with feed tracked updates. In yet another embodiment, the message can be added to a profile of the user adding the message.
In step 630, database system identifies followers of the first user. In one embodiment, the database system can identify the followers as described above for method 500. In various embodiments, a follower can select to follow a feed about the actions of the first user, messages about the first user, or both (potentially in a same feed).
In step 640, the message is added to a news feed of each follower. In one embodiment, the message is only added to a news feed of a particular follower if the message matches some criteria, e.g., the message includes a particular keyword or other criteria. In another embodiment, a message can be deleted by the user who created the message. In one implementation, once deleted by the author, the message is deleted from all feeds to which the message had been added.
In step 650, the follower accesses a news feed and sees the message. For example, the follower can access a news feed on the user's own profile page. As another example, the follower can have a news feed sent to his/her own desktop without having to first go to a home page.
In step 660, database system receives a comment about the message. The database system can add the comment to a feed of the same first user, much as the original message was added. In one embodiment, the comment can also be added to a feed of the user adding the comment. In one implementation, users can also reply to the comment. In another embodiment, users can add comments to a feed tracked update, and further comments can be associated with the feed tracked update. In yet another embodiment, making a comment or message is not an action to which a feed tracked update is created. Thus, the message may be the only feed item created from such an action.
In one implementation, if a feed tracked update (or post) is deleted, its corresponding comments are deleted as well. In another embodiment, new comments on a feed tracked update (or post) do not update the feed tracked update timestamp. Also, the feed tracked update or post can continue to be shown in a feed (profile feed, record feed, or news feed) if it has had a comment within a specified timeframe (e.g. within the last week). Otherwise, the feed tracked update (post) can be removed in an embodiment.
In some embodiments, all or most feed tracked updates can be commented on. In other embodiments, feed tracked updates for certain records (e.g. cases or ideas) are not commentable. In various embodiments, comments can be made for any one or more records of opportunities, accounts, contacts, leads, and custom objects.
In step 670, the comment is added to a news feed of each follower. In one embodiment, a user can make the comment within the user's news feed. Such a comment can propagate to the appropriate profile feed or record feed, and then to the news feeds of the following users. Thus, feeds can include what people are saying, as well as what they are doing. In one aspect, feeds are a way to stay up-to-date (e.g. on users, opportunities, etc.) as well as an opportunity to reach out to your co workers/partners and engage them around common goals.
In some embodiments, users can rate feed tracked updates or messages (including comments). A user can choose to prioritize a display of a feed so that higher rated feed items show up higher on a display. For example, in an embodiment where comments are answers to a specific question, users can rate the different status posts so that a best answer can be identified. As another example, users are able to quickly identify feed items that are most important as those feed items can be displayed at a top of a list. The order of the feed items can be based on an importance level (which can be determined by the database system using various factors, some of which are mentioned herein) and based on a rating from users. In one embodiment, the rating is on a scale that includes at least 3 values. In another embodiment, the rating is based on a binary scale.
Besides a profile for a user, a group can also be created. In various embodiments, the group can be created based on certain criteria that are common to the users, can be created by inviting users, or can be created by receiving requests to join from a user. In one embodiment, a group feed can be created, with messages being added to the group feed when someone adds a message to the group as a whole. For example, a group page may have a section for posts. In another embodiment, a message can be added to a group feed when a message is added about any one of the members. In yet another embodiment, a group feed can include feed tracked updates about actions of the group as a whole (e.g. when an administrator changes data in a group profile or a record owned by the group), or about actions of an individual member.
 FIG. 7 shows an example of a group feed on a group page according to embodiments. As shown, a feed item 710 shows that a user has posted a document to the group object. The text âBill Bauer has posted the document Competitive Insightsâ can be generated by the database system in a similar manner as feed tracked updates about a record being changed. A feed item 720 shows a post to the group, along with comments 730.
 FIG. 8 shows an example of a record feed containing a feed tracked update, post, and comments according to embodiments. Feed item 810 shows a feed tracked update based on the event of submitting a discount for approval. Other feed items show posts that are made to the record and comments that are made on the posts.
VII. Infrastructure for a Feed
A. Tables Used to Create a Feed
 FIG. 9A shows a plurality of tables that may be used in tracking events and creating feeds according to embodiments. The tables of FIG. 9A may have entries added, or potentially removed, as part of tracking events in the database from which feed items are creates or that correspond to feed items. In one embodiment, each tenant has its own set of tables that are created based on criteria provided by the tenant.
An event hifeed tracked update table 910 can provide a hifeed tracked update of events from which feed items are created. In one aspect, the events are for objects that are being tracked. Thus, table 910 can store change hifeed tracked updates for feeds, and the changes can be persisted. In various embodiments, event hifeed tracked update table 910 can have columns of event ID 911, object ID 912 (also called parent ID), and created by ID 913. The event ID 911 can uniquely identify a particular event and can start at 1 (or other number or value).
Each new event can be added chronologically with a new event ID, which may be incremented in order. An object ID 912 can be used to track which record or user's profile is being changed. For example, the object ID can correspond to the record whose field is being changed or the user whose feed is receiving a post. The created by ID 913 can track the user who is performing the action that results in the event, e.g., the user that is changing the field or that is posting a message to the profile of another user.
In some other embodiments, event hifeed tracked update table 910 can have one or more of the following variables with certain attributes: ORGANIZATION_ID being CHAR(15 BYTE), FEEDS_ENTITY_HIFEED TRACKED UPDATE_ID being CHAR(15 BYTE), PARENT_ID being CHAR(15 BYTE), CREATED_BY being CHAR(15 BYTE), CREATED_DATE being a variable of type DATE, DIVISION being a NUMBER, KEY_PREFIX being CHAR(3 BYTE), and DELETED being CHAR(1 BYTE). The parent ID can provide an ID of a parent object in case the change is promulgated to the parent. The key prefix can provide a key that is unique to a group of records, e.g. custom records (objects). The deleted variable can indicate that the feed items for the event are deleted, and thus the feed items are not generated. In one embodiment, the variables for each event entry or any entry in any of the tables may not be nullable. In another embodiment, all entries in the event hifeed tracked update table 910 are used to create feed items for only one object, as specified by the object ID 912. For example, one feed tracked update cannot communicate updates on two records, such as updates of an account field and an opportunity field.
In one embodiment, a name of an event can also be stored in table 910. In one implementation, a tenant can specify events that they want tracked. In an embodiment, event hifeed tracked update table 910 can include the name of the field that changed (e.g. old and new values). In another embodiment, the name of the field, and the values, are stored in a separate table. Other information about an event (e.g. text of comment, feed tracked update, post or status update) can be stored in event hifeed tracked update table 910, or in other tables, as is now described.
A field change table 920 can provide a hifeed tracked update of the changes to the fields. The columns of table 920 can include an event ID 921 (which correlates to the event ID 911), an old value 922 for the field, and the new value 923 for the field. In one embodiment, if an event changes more than one field value, then there can be an entry for each field changed. As shown, event ID 921 has two entries for event E37.
In some other embodiments, field change table 920 can have one or more of the following variables with certain attributes: ORGANIZATION_ID being CHAR(15 BYTE), FEEDS_ENTITY_HIFEED TRACKED UPDATE_FIELDS_ID being CHAR(15 BYTE) and identifying each entry, FEEDS_ENTITY_HIFEED TRACKED UPDATE_ID being CHAR(15 BYTE), FIELD_KEY being VARCHAR2(120 BYTE), DATA_TYPE being CHAR(1 BYTE), OLDVAL_STRING VARCHAR2 being (765 BYTE), NEWVAL_STRING being VARCHAR2(765 BYTE), OLDVAL_FIRST_NAME being VARCHAR2(765 BYTE), NEWVAL_FIRST_NAME being VARCHAR2(765 BYTE), OLDVAL_LAST_NAME being VARCHAR2(765 BYTE), NEWVAL_LAST_NAME being VARCHAR2(765 BYTE), OLDVAL_NUMBER being NUMBER, NEWVAL_NUMBER being NUMBER, OLDVAL_DATE being DATE, NEWVAL_DATE being DATE, and DELETED being CHAR(1 BYTE). In one embodiment, one or more of the variables for each entry in any of the tables may be nullable.
In one embodiment, the data type variable (and/or other variables) is a non-api-insertable field. In another embodiment, variable values can be derived from the record whose field is being changed. Certain values can be transferred into typed columns old/new value string, old/new value number or old/new value date depending upon the derived values. In another embodiment, there can exist a data type for capturing add/deletes for child objects. The child ID can be tracked in the foreign-key column of the record. In yet another embodiment, if the field name is pointing to a field in the parent entity, a field level security (FLS) can be used when a user attempts to a view a relevant feed item. Herein, security levels for objects and fields are also called access checks and determinations of authorization. In one aspect, the access can be for create, read, write, update, or delete of objects.
In one embodiment, the field name (or key) can be either a field name of the entity or one of the values in a separate list. For example, changes that do not involve the update of an existing field (e.g. a close or open) can have a field name specified in an enumerated list. This enumerated list can store âspecialâ field name sentinel values for non-update actions that a tenant wants to track. In one aspect, the API just surfaces these values and the caller has to check the enumerated values to see if it is a special field name.
A comment table 930 can provide a hifeed tracked update of the comments made regarding an event, e.g., a comment on a post or a change of a field value. The columns of table 930 can include an event ID 921 (which correlates to the event ID 911), the comment column 932 that stores the text of the comment, and the time/date 933 of the comment. In one embodiment, there can be multiple comments for each event. As shown, event ID 921 has two entries for event E37.
In some other embodiments, comment table 930 can have one or more of the following variables with certain attributes: ORGANIZATION_ID being CHAR(15 BYTE), FEEDS_COMMENTS_ID being CHAR(15 BYTE) and uniquely identifying each comment, PARENT_ID being CHAR(15 BYTE), CREATED_BY being CHAR(15 BYTE), CREATED_DATE being DATE, COMMENTS being VARCHAR2(420 BYTE), and DELETED being CHAR(1 BYTE).
A user subscription table 940 can provide a list of the objects being followed (subscribed to) by a user. In one embodiment, each entry has a user ID 941 of the user doing the following and one object ID 942 corresponding to the object being followed. In one implementation, the object being followed can be a record or a user. As shown, the user with ID U819 is following object IDs O615 and O489. If user U819 is following other objects, then additional entries may exist for user U819. Also as shown, user U719 is also following object O615. The user subscription table 940 can be updated when a user adds or deletes an object that is being followed.
In some other embodiments, comment table 940 can be composed of two tables (one for records being followed and one for users being followed). One table can have one or more of the following variables with certain attributes: ORGANIZATION_ID being CHAR(15 BYTE), ENTITY_SUBSCRIPTION_ID being CHAR(15 BYTE), PARENT_ID being CHAR(15 BYTE), CREATED_BY being CHAR(15 BYTE), CREATED_DATE being DATE, and DELETED being CHAR(1 BYTE). Another table can have one or more of the following variables with certain attributes: ORGANIZATION_ID being CHAR(15 BYTE), USER_SUBSCRIPTIONS_ID being CHAR(15 BYTE), USER_ID being CHAR(15 BYTE), CREATED_BY being CHAR(15 BYTE), and CREATED_DATE being DATE.
In one embodiment, regarding a profile feed and a news feed, these are read-only views on the event hifeed tracked update table 910 specialized for these feed types. Conceptually the news feed can be a semi-join between the entity subscriptions table 940 and the event hifeed tracked update table 910 on the object IDs 912 and 942 for the user. In one aspect, these entities can have polymorphic parents and can be subject to a number of restrictions detailed herein, e.g., to limit the cost of sharing checks.
In one embodiment, entity feeds are modeled in the API as a feed associate entity (e.g. AccountFeed, CaseFeed etc). A feed associate entity includes information composed of events (e.g. event IDs) for only one particular record type. Such a list can limit the query (and sharing checks) to a specific record type. In one aspect, this structuring of the entity feeds can make the query run faster. For example, a request for a feed of a particular account can include the record type of account. In one implementation, an account feed table can then be searched, where the table has account record IDs and corresponding event IDs or pointers to particular event entries in event hifeed tracked update table 910. Since the account feed table only contains some of the records (not all), the query can run faster.
In one embodiment, there may be objects with no events listed in the event hifeed tracked update table 910, even though the record is being tracked. In this case, the database service can return a result indicating that no feed items exist.
In another embodiment, tables can also exist for audit tracking, e.g., to examine that operations of the system (e.g. access checks) are performing accurately. In one embodiment, audit change-hifeed tracked update tables can be persisted (e.g. in bulk) synchronously in the same transaction as feed events are added to event hifeed tracked update table 910. In another embodiment, entries to the two sets of table can be persisted in asynchronous manner (e.g. by forking a bulk update into a separate java thread). In one aspect, some updates to any of the tables can get lost if the instance of the table goes down while the update has not yet finished. This asynchronous manner can limit an impact performance on save operations. In some embodiments, a field âpersistence typeâ (tri state: AUDIT, FEEDS or BOTH) can be added to capture user preferences, as opposed to being hardcoded.
B. Feed Item
A feed item can represent an individual field change of a record, creation and deletion of a record, or other events being tracked for a record or a user. In one embodiment, all of the feed items in a single transaction (event) can be grouped together and have the same event ID. A single transaction relates to the operations that can be performed in a single communication with the database. In another embodiment where a feed is an object of the database, a feed item can be a child of a profile feed, news feed, or entity feed. If a feed item is added to multiple feeds, the feed item can be replicated as a child of each feed to which the feed item is added.
In one implementation, a feed item is visible only when its parent feed is visible, which can be the same as needing read access on the feed's parent (which can be by the type of record or by a specific record). The feed item's field may be only visible when allowed under field-level security (FLS). Unfortunately, this can mean that the parent feed may be visible, but the child may not be because of FLS. Such access rules are described in more detail below. In one embodiment, a feed item can be read-only. In this embodiment, after being created, the feed item cannot be changed.
In multi-currency organizations, a feed item can have an extra currency code field. This field can give the currency code for the currency value in this field. In one aspect, the value is undefined when the data type is anything other than currency.
C. Feed Comment
In some embodiments, a comment exists as an item that depends from feed tracked updates, posts, status updates, and other items that are independent of each other. Thus, a feed comment object can exist as a child object of a feed item object. For example, comment table 930 can be considered a child table of event hifeed tracked update table 910. In one embodiment, a feed comment can be a child of a profile feed, news feed, or entity feed that is separate from other feed items.
In various embodiments, a feed comment can have various permissions for the following actions. For read permission, a feed comment can be visible if the parent feed is visible. For create permission, if a user has access to the feed (which can be tracked by the ID of the parent feed), the user can add a comment. For delete, only a user with modify all data permission or a user who added the comment can delete the comment. Also delete permission can require access on the parent feed. An update of a comment can be restricted, and thus not be allowed.
In one embodiment, regarding a query restriction, a feed comment cannot be queried directly, but can be queried only via the parent feed. An example is âselect id, parentid, (select . . . from feedcomment) from entityfeedâ. In another embodiment, a feed comment can be directly queries, e.g., by querying comment table 930. A query could include the text of a comment or any other column of the table.
In another embodiment, regarding soft delete behavior, a feed comment table does not have a soft delete column. A soft delete allows an undelete action. In one implementation, a record can have a soft delete. Thus, when the record is deleted, the feed (and its children) can be soft deleted. Therefore, in one aspect, a feed comment cannot be retrieved via the âqueryâ verb (which would retrieve only the comment), but can be retrieved via âqueryAllâ verb though. An example is queryAll(âselect id, (select id, commentbody from feedcomments) from accountfeed where parentid=â001x000xxx3MkADAA0ââ); //where â001x000xxx3MkADAA0â has been soft deleted. When a hard delete (a physical delete) happens, the comment can be hard deleted from the database.
In one embodiment, regarding an implicit delete, feeds with comments are not deleted by a reaper (a routine that performs deletion). In another embodiment, a user cannot delete a feed. In yet another embodiment, upon lead convert (e.g. to an opportunity or contact), the feed items of the lead can be hard deleted. This embodiment can be configured to perform such a deletion for any change in record type. In various implementations, only the comments are hard deleted upon a lead convert, other convert, or when the object is deleted (as mentioned above).
In one embodiment, viewing a feed pulls up the most recent messages or feed tracked updates (e.g. 25) and searches the most recent (e.g. 4) comments for each feed item. The comments can be identified via the comment table 930. In one implementation, a user can request to see more comments, e.g., by selecting a see more link.
In some embodiments, user feeds and/or entity feeds have a last comment date field. In various embodiments, the last comment date field is stored as a field of a record or a user profile. For feeds with no comments, this can be the same as the created date. Whenever a new comment is created, the associated feed's last comment date can be updated with the created date of the comment. The last comment date is unchanged if a feed comment is deleted. A use case is to allow people to order their queries to see the feeds which have been most recently commented on.
D. Creating Custom Feeds by Customizing the Event Hifeed Tracked Update Table
In some embodiments, a tenant (e.g. through an administrator) or a specific user of a tenant can specify the types of events for which feed items are created. A user can add more events or remove events from a list of events that get added to the event hifeed tracked update table 910. In one embodiment, a trigger can be added as a piece of code, rule, or item on a list for adding a custom event to the event hifeed tracked update table 910. These custom events can provide customers the ability to create their own custom feeds and custom feed items to augment or replace implicitly generated feeds via event hifeed tracked update table 910. Implicitly generated feed data can be created when feed-tracking is enabled for certain entities/field-names. In one embodiment, in order to override implicit feeds, feed tracking can be turned off and then triggers can be defined by the user to add events to the event hifeed tracked update table 910. In other embodiments, users are not allowed to override the default list of events that are added to table 910, and thus cannot define their own triggers for having events tracked.
For example, upon lead convert or case close, a default action to be taken by the system may be to add multiple events to event hifeed tracked update table 910. If a customer (e.g. a tenant or a specific user) does not want each of these events to show up as feed items, the customer can turn off tracking for the entities and generate custom feeds by defining customized triggers (e.g. by using an API) upon the events. As another example, although data is not changed, a customer may still want to track an action on a record (e.g. status changes if not already being tracked, views by certain people, retrieval of data, etc.).
In one embodiment, if a user does not want a feed item to be generated upon every change on a given field, but only if the change exceeds a certain threshold or range, then such custom feeds can be conditionally generated with the customized triggers. In one implementation, the default tracking for the record or user may be turned off for this customization so that the events are only conditionally tracked. In another implementation, a trigger can be defined that deletes events that are not desired, so that default tracking can still be turned on for a particular object type. Such conditional tracking can be used for other events as well.
In some embodiments, defining triggers to track certain events can be done as follows. A user can define an object type to track. This object type can be added to a list of objects that can be tracked for a particular tenant. The tenant can remove object types from this list as well. Custom objects and standard objects can be on the list, which may, for example, be stored in cache or RAM of a server or in the database. Generally only one such list exists for a tenant, and users do not have individual lists for themselves, although in some embodiments, they may particularly when the number of users in a tenant is small.
In one embodiment, a tenant can select which records of an object type are to be tracked. In another embodiment, once an object type is added to the tracking list of object types, then all records of that type are tracked. The tenant can then specify the particulars of how the tracking is to be performed. For example, the tenant can specify triggers as described above, fields to be tracked, or any of the customizations mentioned herein.
In some embodiments, when a feed is defined as an object in the database (e.g. as a child object of entity records that can be tracked), a particular instance of the feed object (e.g. for a particular record) can be create-able and delete-able. In one embodiment, if a user has access to a record then the user can customize the feed for the record. In one embodiment, a record may be locked to prevent customization of its feed.
One method of creating a custom feed for users of a database system according to embodiments is now described. Any of the following steps can be performed wholly or partially with the database system, and in particular by one or more processor of the database system.
In step A, one or more criteria specifying which events are to be tracked for possible inclusion into a feed to be displayed are received from a tenant. In step B, data indicative of an event is received. In step C, the event is analyzed to determine if the criteria are satisfied. In step D, if the criteria are satisfied, at least a portion of the data is added to a table (e.g. one or more of the tables in FIG. 9A) that tracks events for inclusion into at least one feed for a user of the tenant. The feed in which feed items of an event may ultimately be displayed can be a news feed, record feed, or a profile feed.
E. Creating Custom Feeds with Filtering
After feed items have been generated, they can be filtered so that only certain feed items are displayed, which may be tailored to a specific tenant and/or user. In one embodiment, a user can specify changes to a field that meet certain criteria for the feed item to show up in a feed displayed to the user, e.g., a news feed or even an entity feed displayed directly to the user. In one implementation, the criteria can be combined with other factors (e.g. number of feed items in the feed) to determine which feed items to display. For instance, if a small number of feed items exist (e.g. below a threshold), then all of the feed items may be displayed.
In one embodiment, a user can specify the criteria via a query on the feed items in his/her new feed, and thus a feed may only return objects of a certain type, certain types of events, feed tracked updates about certain fields, and other criteria mentioned herein. Messages can also be filtered according to some criteria, which may be specified in a query. Such an added query can be added onto a standard query that is used to create the news feed for a user. A first user could specify the users and records that the first user is following in this manner, as well as identify the specific feed items that the first user wants to follow. The query could be created through a graphical interface or added by a user directly in a query language. Other criteria could include receiving only posts directed to a particular user or record, as opposed to other feed items.
In one embodiment, the filters can be run by defining code triggers, which run when an event, specific or otherwise, occurs. The trigger could then run to perform the filtering at the time the event occurs or when a user (who has certain defined triggers, that is configured for a particular user) requests a display of the feed. A trigger could search for certain terms (e.g. vulgar language) and then remove such terms or not create the feed item. A trigger can also be used to send the feed item to a particular person (e.g. an administrator) who does not normally receive the feed item were it not for the feed item containing the flagged terms.
F. Access Checks
In one embodiment, a user can access a feed of a record if the user can access the record. The security rules for determining whether a user has access to a record can be performed in a variety of ways, some of which are described in U.S. patent application Ser. No. 11/866,184 by Weissman et al., filed Oct. 2, 2007, titled âMETHODS AND SYSTEMS FOR CONTROLLING ACCESS TO CUSTOM OBJECTS IN A DATABASEâ, which is hereby incorporated by reference in its entirety and for all purposes. For example, a security level table can specify whether a user can see a particular type of record and/or particular records. In one implementation, a hierarchy of positions within a tenant is used. For example, a manager can inherit the access levels of employees that the manager supervises. Field level security (FLS) can also be used to determine whether a particular feed tracked update about an update to a field can be seen by the user. The field change table 920 can be used to identify a field name or field ID, and then whether the user has read access to that field can be determined from an FLS table. For example, if a user could not see a field of a social security number, the feed of the user provided to the user would not include any feed items related to the social security number field.
In one embodiment, a user can edit a feed of a record if the user has access to the record, e.g., deleting or editing a feed item. In another embodiment, a user (besides an administrator) cannot edit a feed item, except for performing an action from which a feed item can be created. In one implementation, a user is required to have access to a particular record and field for a feed item to be created based on an action of the user. In this case, an administrator can be considered to be a user with MODIFY-ALL-DATA security level. In yet another embodiment, a user who created the record can edit the feed.
G. Posts
In one embodiment, the text of posts are stored in a child table (post table 950), which can be cross-referenced with event hifeed tracked update table 910. Post table 950 can include event ID 951 (to cross-reference with event ID 911), post text 952 to store the text of the post, and time/date 953. An entry in post table 950 can be considered a feed post object. Posts for a record can also be subject to access checks. In one implementation, if a user can view a record then all of the posts can be seen, i.e. there is not an additional level of security check as there is for FLS. In another implementation, an additional security check could be done, e.g., by checking on whether certain keywords (or phrases) exist in the post. For instance, a post may not be not provided to specified users if a certain keyword exists, or only provided to specified users if a keyword exists. In another embodiment, a table can exist for status updates.
VIII. Subscribing to Users and Records to Follow
As described above, a user can follow users, groups, and records. Embodiments can provide mechanisms for a user to manage which users, groups, and records that the user is currently following. In one embodiment, a user can be limited to the number of users and records (collectively or separately) that the user can follow. For example, a user may be restricted to only following 10 users and 15 records, or as another example, 25 total. Alternatively, the user may be permitted to follow more or less users.
In one embodiment, a user can go to a page of a record and then select to follow that object (e.g., with a button marked âfollowâ or âjoinâ). In another embodiment, a user can search for a record and have the matching records show up in a list. The search can include criteria of records that the user might want to follow. Such criteria can include the owner, the creation date, last comment date, and numerical values of particular fields (e.g. an opportunity with a value of more than $10,000).
A follow button (or other activation object) can then reside next to each record in the resulting list, and the follow button can be selected to start following the record. Similarly, a user can go to a profile page of a user and select to follow the user, or a search for users can provide a list, where one or more users can be selected for following from the list. The selections of subscribing and unsubscribing can add and delete rows in table 920.
In some embodiments, a subscription center acts as a centralized place in a database application (e.g. application platform 18) to manage which records a user subscribes to, and which field updates the user wants to see in feed tracked updates. The subscription center can use a subscription table to keep track of the subscriptions of various users. In one embodiment, the subscription center shows a list of all the items (users and records) a user is subscribed to. In another embodiment, a user can unsubscribe to subscribed objects from the subscription center.
A. Automatic Subscription
In one embodiment, an automatic subscription feature can ensure that a user is receiving certain feeds. In this manner, a user does not have to actively select certain objects to follow. Also, a tenant can ensure that a user is following objects that the user needs to be following.
In various embodiments for automatically following users, a default for small organizations can be to follow everyone. For big organizations, the default can be to follow a manager and peers. If a user is a manager, the default can be to follow the manager's supervisor, peers, and people that the manager supervises (subordinates). In other embodiments for automatically following records, records that the user owns may be automatically followed and/or records recently viewed (or changed) may be automatically followed.
In one example, a new record is created. The owner (not necessarily the user who created the entity) is subscribed to the entity. If ownership is changed, the new owner may automatically be subscribed to follow the entity. Also, after a lead convert, the user doing the lead convert may be automatically subscribed to the new account, opportunity, or contact resulting from the lead convert. In one implementation, the auto subscription is controlled by user preference. That is a user or tenant can have the auto subscribe feature enabled or not. In one aspect, the default is to have the auto-subscribe turned on.
 FIG. 9B shows a flowchart illustrating a method 900 for automatically subscribing a user to an object in a database system according to embodiments. Any of the following steps can be performed wholly or partially with the database system, and in particular by one or more processor of the database system.
In step 901, one or more properties of an object stored in the database system are received. The properties can be received from administrators of the database system, or from users of the database system (which may be an administrator of a customer organization). The properties can be records or users, and can include any of the fields of the object that are stored in the database system. Examples of properties of a record include: an owner of the record, a user that converted the record from one record type to another record type, whether the first user has viewed the record, and a time the first user viewed the record. Examples of properties of a user include: which organization (tenant) the user is associated with, the second user's position in the same organization, and which other users the user had e-mailed or worked with on projects.
In step 902, the database system receives one or more criteria about which users are to automatically follow the object. The criteria can be received from administrators of the database system, or from one or more users of the database system. The users may be an administrator of a customer organization, which can set tenant-wide criteria or criteria for specific users (who may also set the criteria themselves). Examples of the criteria can include: an owner or creator of a record is to follow the record, subordinates of an owner or creator of a record are to follow the record, a user is to follow records recently viewed (potentially after a specific number of views), records that a user has changed values (potentially with a date requirement), records created by others in a same business group as the user. Examples of the criteria can also include: a user is to follow his/her manager, the user's peers, other users in the same business group as the user, and other users that the user has e-mailed or worked with on a project. The criteria can be specific to a user or group of users (e.g. users of a tenant).
In step 903, the database system determines whether the one or more properties of the object satisfy the one or more criteria for a first user. In one embodiment, this determination can occur by first obtaining the criteria and then determining objects that satisfy the criteria. The determination can occur periodically, at time of creation of an object, or at other times. If different users have different criteria, then the criteria for a particular user or group could be searched at the same time. Since users of different tenants normally cannot view objects of another tenant, certain criteria does not have to be checked. In another embodiment, this determination can occur by looking at certain properties and then identifying any criteria that are met. In yet another embodiment, the criteria and properties can be used to find users that satisfy the criteria.
In step 904, if the criteria are satisfied, the object is associated with the first user. The association can be in a list that stores information as to what objects are being followed by the first user. User subscription table 940 is an example of such a list. In one embodiment, the one or more criteria are satisfied if one property satisfies at least one criterion. Thus, if the criteria are that a user follows his/her manager and the object is the user's manager, then the first user will follow the object.
In one embodiment, a user can also be automatically unsubscribed, e.g. if a certain action happens. The action could be a change in the user's position within the organization, e.g. a demotion or becoming a contractor. As another example, if a case gets closed, then users following the case may be automatically unsubscribed.
B. Feed and Subscription API
In one embodiment, a feed and subscription center API can enable tenants to provide mechanisms for tracking and creating feed items, e.g., as described above for creating custom feeds by allowing users to add custom events for tracking. For example, after some initial feed items are created (e.g. by administrators of the database system), outside groups (e.g. tenants or software providers selling software to the tenants) can âenable objectsâ for feeds through a standard API. The groups can then integrate into the subscription center and the feed tracked update feeds on their own. In one embodiment, the feed and subscription center API can use a graphical user interface implemented for the default feed tracking. In one embodiment, API examples include subscribing to an entity by creating a new entity subscription object for a particular user ID, or for all users of a tenant (e.g. user subscription table 940). In one embodiment, obtaining all subscriptions for a given user can be performed by using a query, such as âselect . . . from EntitySubscription where userid=â . . . ââ.
Some embodiments have restriction on non-admin users, e.g. those without view all data permissions (VAD). One restriction can be a limit clause on entity subscription queries (e.g. queries on user subscription table 940), e.g., where the limit of the number of operations is less than 100. In one embodiment, users are not required to specify an order-by, but if an order-by is specified they can only order on fields on the entity subscription entity. In one implementation, filters on entity subscription can likewise only specify fields on the entity subscription entity. In one aspect, the object ID being followed can be sorted or filtered, but not the object name.
In one embodiment, one or more restrictions can also be placed on the identification of feed items in a feed that a user can access. For example, if a low-level user (i.e. user can access few objects) is attempting to see a profile feed of a high level user, a maximum number of checks (e.g. 500) for access rights may be allowed. Such a restriction can minimize a cost of a feed request. In some embodiments, there are restriction on the type of queries (e.g. fields for filtering) allowed to construct on feeds (e.g. on tables in FIG. 9A).
C. Sharing
As mentioned above, users may be restricted from seeing records from other tenants, as well as certain records from the tenant to which the user belongs (e.g. the user's employer). Sharing rules can refer to the access rules that restrict a user from seeing records that the user is not authorized to see or access. Additionally, in one implementation, a user may be restricted to only seeing certain fields of a record, field-level security (FLS).
In an embodiment, access rule checks are done upon subscription. For example, a user is not allowed to subscribe to a record or type of record that the user cannot access. In one aspect, this can minimize (but not necessarily eliminate) cases where a user subscribes to entities they cannot access. Such cases can slow down news feed queries, when an access check is performed (which can end up removing much of the feed items). Thus, a minimization of access checks can speed up operation. In another embodiment, when feed items are created dynamically, access rule checks may be done dynamically at the time of subsequent access, and not upon subscription or in addition to at time of subscription.
An example case where access checks are still performed is when a first user follows a second user, but the second user performs some actions on records or is following records that the first user is not allowed to see. The first user may be allowed to follow the second user, and thus the subscription is valid even though the first user may not be able to see all of the feed items. Before a feed tracked update is provided to a news feed of the first user, a security check may be performed to validate whether the first user has access rights to the feed item. If not, the feed item is not displayed to the first user. In one implementation, users can be blocked from feed items that contain certain terms, symbols, account numbers, etc. In one embodiment, any user can follow another user. In another embodiment, users may be restricted as to which users, objects, and/or records he/she can follow.
Regarding viewing privileges of a feed, in one embodiment, a user can always see all of his own subscriptions (even if he's lost read access to a record). For example, a user can become a contractor, and then the user may lose access to some records. But, the user may still see that he/she is following the object. This can help if there is a limit to the number of objects that can be followed. To unsubscribe a user may need to know what they are following so they can unsubscribe and subscribe to objects the user can see. In another embodiment, for access to other people's subscriptions, a user can be required to need read-access on the record-id to see the subscription. In some embodiments, users with authorization to modify all data can create/delete any subscription. In other embodiments, a user can create/delete subscriptions only for that user, and not anyone else.
D. Configuration of which Field to Follow
There can be various feed settings for which feed items get added to profile and record feeds, and which get added to news feeds. In one embodiment, for profile feeds and entity feeds, feed tracked updates can be written for all standard and custom fields on the supported objects. In one implementation, feed settings can be set to limit how many and which fields of a record are tracked for determining whether a feed tracked update is to be generated. For example, a user or administrator can choose specific fields to track and/or certain ones not to track. In another embodiment, there is a separate limit for the number of trackable fields (e.g. 20) for a record. Thus, only certain changes may be tracked in an entity hifeed tracked update and show up in the feed. In yet another embodiment, default fields may be chosen for tracking, where the defaults can be exposed in the subscriptions center.
IX. Adding Items to a Feed
As described above, a feed includes feed items, which include feed tracked updates and messages, as defined herein. Various feeds can be generated. For example, a feed can be generated about a record or about a user. Then, users can view these feeds. A user can separately view a feed of a record or user, e.g., by going to a home page for the user or the record. As described above, a user can also subscribe (follow) to user or record and receive the feed items of those feeds through a separate feed application (e.g. in a page or window), which is termed âchatterâ in certain examples. The feed application can provide each of the feeds that a user is following in a single news feed.
A feed generator can refer to any software program running on a processor or a dedicated processor (or combination thereof) that can generate feed items (e.g. feed tracked updates or messages) and combine them into a feed. In one embodiment, the feed generator can generate a feed item by receiving a feed tracked update or message, identifying what feeds the item should be added to, and adding the feed. Adding the feed can include adding additional information (metadata) to the feed tracked update or message (e.g. adding a document, sender of message, a determined importance, etc.). The feed generator can also check to make sure that no one sees feed tracked updates for data that they don't have access to see (e.g. according to sharing rules). A feed generator can run at various times to pre-compute feeds or to compute them dynamically, or combinations thereof.
In one embodiment, the feed generator can de-dupe events (i.e. prevent duplicates) that may come in from numerous records (and users). For example, since a feed tracked update can be published to multiple feeds (e.g. John Choe changed the Starbucks Account Status) and a person can be subscribed to both the Starbucks account and John Choe, embodiments can filter out duplicates before adding or displaying the items in a news feed. Thus, the Feed Generator can collapse events with multiple records and users for a single transaction into a single feed tracked update and ensure the right number of feed tracked updates for the particular feed. In some embodiments, an action by a user does not create a feed item for that user (e.g. for a profile feed of that user), and it is only the feed of the object being acted upon (e.g. updated) for which a feed item is created. Thus, there should not be duplicates. For example, if someone updates the status of a record, the feed item is only for the record and not the user.
In one embodiment, processor 417 in FIG. 4 can identify an event that meets criteria for a feed tracked update, and then generate the feed tracked update. Processor 417 can also identify a message. For example, an application interface can have certain mechanisms for submitting a message (e.g. âsubmitâ buttons on a profile page, detail page of a record, âcommentâ button on post), and use of these mechanisms can be used to identify a message to be added to a table used to create a feed or added directly to a list of feed items ready for display.
A. Adding Items to a Pre-Computed Feed
In some embodiments, a feed of feed items is created before a user requests the feed. Such an embodiment can run fast, but have high overall costs for storage. In one embodiment, once a profile feed or a record feed has been created, a feed item (messages and feed tracked updates) can be added to the feed. The feed can exist in the database system in a variety of ways, such as a related list. The feed can include mechanisms to remove items as well as add them.
As described above, a news feed can be an aggregated feed of all the record feeds and profile feeds to which a user has subscribed. The news feed can be provided on the home page of the subscribing user. Therefore, a news feed can be created by and exist for a particular user. For example, a user can subscribe to receive entity feeds of certain records that are of interest to the user, and to receive profile feeds of people that are of interest (e.g. people on a same team, that work for the user, are a boss of the user, etc.). A news feed can tell a user about all the actions across all the records (and people) who have explicitly (or implicitly) subscribed to via the subscriptions center (described above).
In one embodiment, only one instance of each feed tracked update is shown on a user's news feed, even if the feed tracked update is published in multiple entities to which the user is subscribed. In one aspect, there may be delays in publishing news articles. For example, the delay may be due to queued up messages for asynchronous entity hifeed tracked update persistence. Different feeds may have different delays (e.g. delay for new feeds, but none of profile and entity feeds). In another embodiment, certain feed tracked updates regarding a subscribed profile feed or an entity feed are not shown because the user is not allowed access, e.g. due to sharing rules (which restrict which users can see which data). Also, in one embodiment, data of the record that has been updated (which includes creation) can be provided in the feed (e.g. a file or updated value of a feed can be added as a flash rendition).
Examples are provided below as how it can be determined which feed items to add to which news feeds. In one embodiment, the addition of items to a news feed is driven by the following user. For example, the user's profile can be checked to determine objects the user is following, and the database may be queried to determine updates to these objects. In another embodiment, the users and records being followed drive the addition of items to a news feed. Embodiments can also combine these and other aspects. In one embodiment, a database system can be follower-driven if the number of subscriptions (users and records the user is following) is small. For example, since the number subscriptions are small, then changes to a small number of objects need to be checked for the follower.
Regarding embodiments that are follower-driven, one embodiment can have a routine run for a particular user. The routine knows the users and records that the user is following. The routine can poll the database system for new feed tracked updates and messages about the users and records that are being followed. In one implementation, the polling can be implemented as queries. In one embodiment, the routine can run at least partially (even wholly) on a user device.
Regarding embodiments where a news feed is driven by the record (or user) being followed, processor 417 can identify followers of the record after a feed item is added to the record feed. Processor 417 can retrieve a list of the followers from the database system. The list can be associated with the record, and can be stored as a related list or other object that is a field or child of the record.
In one embodiment, profile and record feeds can be updated immediately with a new feed item after an action is taken or an event occurs. A news feed can also be updated immediately. In another embodiment, a news feed can be updated in batch jobs, which can run at periodic times.
B. Dynamically Generating Feeds
In some embodiments, a feed generator can generate the feed items dynamically when a user requests to see a particular feed, e.g., a profile feed, entity feed, or the user's news feed. In one embodiment, the most recent feed items (e.g. top 50) are generated first. In one aspect, the other feed items can be generated as a background process, e.g., not synchronously with the request to view the feed. However, since the background process is likely to complete before a user gets to the next 50 feed items, the feed generation may appear synchronous. In another aspect, the most recent feed items may or may not include comments, e.g., that are tied to feed tracked updates or posts.
In one embodiment, the feed generator can query the appropriate subset of tables shown in FIG. 9A and/or other tables as necessary, to generate the feed items for display. For example, the feed generator can query the event hifeed tracked update table 910 for the updates that occurred for a particular record. The ID of the particular record can be matched against the ID of the record. In one embodiment, changes to a whole set of records can be stored in one table. The feed generator can also query for status updates, posts, and comments, each of which can be stored in different parts of a record or in separate tables, as shown in FIG. 9A. What gets recorded in the entity hifeed tracked update table (as well as what is displayed) can be controlled by a feed settings page in setup, which can be configurable by an administrator and can be the same for the entire organization, as is described above for custom feeds.
In one embodiment, there can be two feed generators. For example, one generator can generate the record and profile feeds and another generator can generate news feeds. For the former, the feed generator can query identifiers of the record or the user profile. For the latter, the news feed generator can query the subscribed profile feeds and record feeds, e.g., user subscription table 940. In one embodiment, the feed generator looks at a person's subscription center to decide which feeds to query for and return a list of feed items for the user. The list can be de-duped, e.g., by looking at the event number and values for the respective table, such as field name or ID, comment ID, or other information.
C. Adding Information to Feed Hifeed Tracked Update Tables
 FIG. 10 is a flowchart of a method 1000 for saving information to feed tracking tables according to embodiments. In one embodiment, some of the steps may be performed regardless of whether a specific event or part of an event (e.g. only one field of an update is being tracked) is being tracked. In various embodiments, a processor or set of processors (hardwired or programmed) can perform method 1000 and any other method described herein.
In step 1010, data indicative of an event is received. The data may have a particular identifier that specifies the event. For example, there may be a particular identifier for a field update. In another embodiment, the transaction may be investigated for keywords identifying the event (e.g., terms in a query indicating a close, change field, or create operations).
In step 1020, it is determined whether the event is being tracked for inclusion into feed tables. The determination of what is being tracked can be based on a tenant's configuration as described above. In one aspect, the event has an actor (person performing an event), and an object of the event (e.g. record or user profile being changed).
In step 1030, the event is written to an event hifeed tracked update table (e.g. table 910). In one embodiment, this feed tracking operation can be performed in the same transaction that performs a save operation for updating a record. In another embodiment, a transaction includes at least two roundtrip database operations, with one roundtrip being the database save (write), and the second database operation being the saving of the update in the hifeed tracked update table. In one implementation, the event hifeed tracked update table is chronological. In another implementation, if user A posts on user B's profile, then user A is under the âcreated byâ 913 and user B is under the object ID 912.
In step 1040, a field change table (e.g. field change table 920) can be updated with an entry having the event identifier and fields that were changed in the update. In one embodiment, the field change table is a child table of the event hifeed tracked update table. This table can include information about each of the fields that are changed. For example, for an event that changes the name and balance for an account record, an entry can have the event identifier, the old and new name, and the old and new balance. Alternatively, each field change can be in a different row with the same event identifier. The field name or ID can also be included to determine which field the values are associated.
In step 1050, when the event is a post, a post table (e.g. post table 950) can be updated with an entry having the event identifier and text of the post. In one embodiment, the field change table is a child table of the event hifeed tracked update table. In another embodiment, the text can be identified in the transaction (e.g. a query command), stripped out, and put into the entry at the appropriate column. The various tables described herein can be combined or separated in various ways. For example, the post table and the field change table may be part of the same table or distinct tables, or may include overlapping portions of data.
In step 1060, a comment is received for an event and the comment is added to a comment table (e.g. comment table 930). The comment could be for a post or an update of a record, from which a feed tracked update can be generated for display. In one embodiment, the text can be identified in the transaction (e.g. a query command), stripped out, and put into the entry at the appropriate column.
D. Reading Information from Feed Hifeed Tracked Update Tables
 FIG. 11 is a flowchart of a method 1100 for reading a feed item as part of generating a feed for display according to embodiments. In one embodiment, the feed item may be read as part of creating a feed for a record.
In step 1110, a query is received for an event hifeed tracked update table (e.g. event hifeed tracked update table 910) for events related to a particular record. In one embodiment, the query includes an identifier of the record for which the feed is being requested. In various embodiments, the query may be initiated from a detail page of the record, a home page of a user requesting the record feed, or from a listing of different records (e.g. obtained from a search or from browsing).
In step 1120, the user's security level can be checked to determine if the user can view the record feed. Typically, a user can view a record feed, if the user can access the record. This security check can be performed in various ways. In one embodiment, a first table is checked to see if the user has a classification (e.g. a security level that allows him to view records of the given type). In another embodiment, a second table is checked to see if the user is allowed to see the specific record. The first table can be checked before the second table, and both tables can be different sections of a same table. If the user has requested the feed from the detail page of the record, one embodiment can skip the security level check for the record since the check was already done when the user requested to view the detail page.
In one embodiment, a security check is determined upon each request to view the record feed. Thus, whether or not a feed item is displayed to a user is determined based on access rights, e.g., when the user requests to see a feed of a record or a news feed of all the objects the user is following. In this manner, if a user's security changes, a feed automatically adapts to the user's security level when it is changed. In another embodiment, a feed can be computed before being requested and a subsequent security check can be made to determine whether the person still has access right to view the feed items. The security (access) check may be at the field level, as well as at the record level.
In step 1130, if the user can access the record, a field level security table can be checked to determine whether the user can see particular fields. In one implementation, only those fields are displayed to the user. Alternatively, a subset of those the user has access to is displayed. The field level security check may optionally be performed at the same time and even using the same operation as the record level check. In addition, the record type check may also be performed at this time. If the user can only see certain fields, then any feed items related to those fields (e.g. as determined from field change table 920) can be removed from the feed being displayed.
In step 1140, the feed items that the user has access to are displayed. In one embodiment, a predetermined number (e.g. 20) of feed items are displayed at a time. The method can display the first 20 feed items that are found to be readable, and then determine others while the user is viewing the first 20. In another embodiment, the other feed items are not determined until the user requests to see them, e.g., by activating a see more link.
 FIG. 12 is a flowchart of a method 1200 for reading a feed item of a profile feed for display according to embodiments. In one embodiment, the query includes an identifier of the user profile feed that is being requested. Certain steps may be optional, as is also true for other methods described herein. For example, security checks may not be performed.
In step 1210, a query is directed to an event hifeed tracked update table (e.g. event hifeed tracked update table 910) for events having a first user as the actor of the event (e.g. creation of an account) or on which the event occurred (e.g. a post to the user's profile). In various embodiments, the query may be initiated by a second user from the user's profile page, a home page of a user requesting the profile feed (e.g. from a list of users being followed), or from a listing of different users (e.g. obtained from a search or from browsing). Various mechanisms for determining aspects of events and obtaining information from tables can be the same across any of the methods described herein.
In step 1220, a security check may also be performed on whether the second user can see the first user's profile. In one embodiment any user can see the profile of another user of the same tenant, and step 1220 is optional.
In step 1230, a security (access) check can be performed for the feed tracked updates based on record types, records, and/or fields, as well security checks for messages. In one embodiment, only the feed tracked updates related to records that the person has updated are the ones that need security check as the feed items about the user are readable by any user of the same tenant. Users of other tenants are not navigable, and thus security can be enforced at a tenant level. In another embodiment, messages can be checked for keywords or links to a record or field that the second user does not have access.
As users can have different security classifications, it is important that a user with a low-level security cannot see changes to records that have been performed by a user with high-level security. In one implementation, each feed item can be checked and then the viewable results displayed, but this can be inefficient. For example, such a security check may take a long time, and the second user would like to get some results sooner rather than later. The following steps illustrate one embodiment of how security might be checked for a first user that has a lot of feed items, but the second user cannot see most of them. This embodiment can be used for all situations, but can be effective in the above situation.
In step 1231, a predetermined number of entries are retrieved from the event hifeed tracked update table (e.g. starting from the most recent, which may be determined from the event identifier). The retrieved entries may just be ones that match the user ID of the query. In one embodiment, entries are checked to find the entries that are associated with the user and with a record (i.e. not just posts to the user account). In another embodiment, those entries associated with the user are allowed to be viewed, e.g. because the second user can see the profile of the first user as determined in step 1220.
In step 1232, the record identifiers are organized by type and the type is checked on whether the second user can see the record types. Other checks such as whether a record was manually shared (e.g. by the owner) can also be performed. In one embodiment, the queries for the different types can be done in parallel.
In step 1233, if a user can see the record type, then a check can be performed on the specific record. In one embodiment, if a user can see a record type, then the user can see all of the records of that type, and so this step can be skipped. In another embodiment, the sharing model can account for whether a user below the second user (e.g. the second user is a manager) can see the record. In such an embodiment, the second user may see such a record. In one implementation, if a user cannot see a specific record, then comments on that record are also not viewable.
In step 1234, field level sharing rules can be used to determine whether the second user can see information about an update or value of certain fields. In one embodiment, messages can be analyzed to determine if reference to a particular field name is made. If so, then field level security can be applied to the messages.
In step 1280, steps 1231-1234 are repeated until a stopping criterion is met. In one embodiment, the stopping criteria may be when a maximum number (e.g. 100) of entries that are viewable have been identified. In another embodiment, the stopping criteria can be that a maximum number (e.g. 500) of entries from the entity hifeed tracked update table have been analyzed, regardless of whether the entries are viewable or not.
In one embodiment, a news feed can be generated as a combination of the profile feeds and the entity feeds, e.g. as described above. In one implementation, a list of records and user profiles for the queries in steps 1110 and 1210 can be obtained form user subscription table 940. In one embodiment, there is a maximum number of objects that can be followed.
In various embodiments, the entity hifeed tracked update table can be queried for any one or more of the following matching variables as part of determining items for a feed: CreatedDate, CreatedById, CreatedBy.FirstName, CreatedBy.LastName, ParentId, and Parent.Name. The child tables can also be queried for any one or more of the following matching variables as part of determining items for a feed: DataType, FieldName, OldValue, and NewValue. A query can also specify how the resulting feed items can be sorted for display, e.g., by event number, date, importance, etc. The query can also include a number of items to be returned, which can be enforced at the server.
The two examples provided above can be done periodically to create the feeds ahead of time or done dynamically at the time the display of a feed is requested. Such a dynamic calculation can be computationally intensive for a news feed, particularly if many users and records are being followed, although there can be a low demand for storage. Accordingly, one embodiment performs some calculations ahead of time and stores the results in order to create a news feed.
E. Partial Pre-Computing of Items for a Feed
 FIG. 13 is a flowchart of a method 1300 of storing event information for efficient generation of feed items to display in a feed according to embodiments. In various embodiments, method 1300 can be performed each time an event is written to the events hifeed tracked update table, or periodically based on some other criteria (e.g. every minute, after five updates have been made, etc.).
In step 1310, data indicative of an event is received. The data may be the same and identified in the same way as described for step 1010. The event may be written to an event hifeed tracked update table (e.g. table 910).
In step 1320, the object(s) associated with the event are identified. In various embodiments, the object may be identified by according to various criteria, such as the record being changed, the user changing the record, a user posting a message, and a user whose profile the message is being posted to.
In step 1330, the users following the event are determined. In one embodiment, one or more objects that are associated with the event are used to determine the users following the event. In one implementation, a subscription table (e.g. table 940) can be used to find the identified objects. The entries of the identified objects can contain an identifier (e.g. user ID 941) of each the users following the object
In step 1340, the followers of the event are written to a news feed table along with an event identifier. In one embodiment, each follower is added as a separate entry into the news feed table along with the event ID. In another embodiment, each of the events for a user is added as a new column for the row of the user. In yet another embodiment, more columns (e.g. columns from the other tables) can be added.
News feed table 960 shows an example of such a table with user ID 961 and event ID or pointer 962. The table can be organized in any manner. One difference from event hifeed tracked update table 910 is that one event can have multiple entries (one for each subscriber) in the news feed table 960. In one embodiment, all of the entries for a same user are grouped together, e.g., as shown. The user U819 is shown as following events E37 and E90, and thus any of the individual feed items resulting from those events. In another embodiment, any new entries are added at the end of the table. Thus, all of the followers for a new event can be added as a group. In such an embodiment, the event IDs would generally be grouped together in the table. Of course, the table can be sorted in any suitable manner.
In an embodiment, if the number of users is small, then the feed items in one or more of the tables may be written as part of the same write transaction. In one implementation, the determination of small depends on the number of updates performed for the event (e.g. a maximum number of update operations may be allowed), and if more operations are performed, then the addition of the feed items is performed. In one aspect, the number of operations can be counted by the number of rows to be updated, including the rows of the record (which depends on the update event), and the rows of the hifeed tracked update tables, which can depend on the number of followers. In another embodiment, if the number of users is large, the rest of the feed items can be created by batch. In one embodiment, the feed items are always written as part of a different transaction, i.e., by batch job.
In one embodiment, security checks can be performed before an entry is added to the news feed table 960. In this manner, security checks can be performed during batch jobs and may not have to be performed at the time of requesting a news feed. In one implementation, the event can be analyzed and if access is not allowed to a feed item of the event, then an entry is not added. In one aspect, multiple feed items for a same user may not result from a same event (e.g. by how an event is defined in table 910), and thus there is no concern about a user missing a feed item that he/she should be able to view.
In step 1350, a request for a news feed is received from a user. In one embodiment, the request is obtained when a user navigates to the user's home page. In another embodiment, the user selects a table, link, or other page item that causes the request to be sent.
In step 1360, the news feed table and other tables are accessed to provide displayable feed items of the news feed. The news feed can then be displayed. In one embodiment, the news feed table can then be joined with the event hifeed tracked update table to determine the feed items. For example, the news feed table 960 can be searched for entries with a particular user ID. These entries can be used to identify event entries in event hifeed tracked update table 910, and the proper information from any child tables can be retrieved. The feed items (e.g., feed tracked updates and messages) can then be generated for display.
In one embodiment, the most recent feed items (e.g. 100 most recent) are determined first. The other feed items may then be determined in a batch process. Thus, the feed item that a user is most likely to view can come up first, and the user may not recognize that the other feed items are being done in batch. In one implementation, the most recent feed items can be gauged by the event identifiers. In another embodiment, the feed items with a highest importance level can be displayed first. The highest importance being determined by one or more criteria, such as, who posted the feed item, how recently, how related to other feed items, etc.
In one embodiment where the user subscription table 940 is used to dynamically create a news feed, the query would search the subscription table, and then use the object IDs to search the event hifeed tracked update table (one search for each object the user is following). Thus, the query for the news feed can be proportional to the number of objects that one was subscribing to. The news feed table allows the intermediate step of determining the object IDs to be done at an earlier stage so that the relevant events are already known. Thus, the determination of the feed is no longer proportional to the number of object being followed.
In some embodiments, a news feed table can include a pointer (as opposed to an event identifier) to the event hifeed tracked update table for each event that is being followed by the user. In this manner, the event entries can immediately be retrieved without having to perform a search on the event hifeed tracked update table. Security checks can be made at this time, and the text for the feed tracked updates can be generated.
X. Display of a Feed
Feeds include messages and feed tracked updates and can show up in many places in an application interface with the database system. In one embodiment, feeds can be scoped to the context of the page on which they are being displayed. For example, how a feed tracked update is presented can vary depending on which page it is being displayed (e.g. in news feeds, on a detail page of a record, and even based on how the user ended up at a particular page). In another embodiment, only a finite number of feed items are displayed (e.g. 50). In one implementation, there can be a limit specifically on the number of feed tracked updates or messages displayed. Alternatively, the limit can be applied to particular types of feed tracked updates or messages. For example, only the most recent changes (e.g. 5 most recent) for a field may be displayed. Also, the number of fields for which changes are displayed can also be limited. Such limits can also be placed on profile feeds and news feeds. In one embodiment, feed items may also be subject to certain filtering criteria before being displayed, e.g., as described below.
A. Sharing Rules for Feeds
As mentioned above, a user may not be allowed to see all of the records in the database, and not even all of the records of the organization to which the user belongs. A user can also be restricted from viewing certain fields of a record that the user is otherwise authorized to view. Accordingly, certain embodiments use access rules (also called sharing rules and field-level security FLS) to ensure that a user does not view a feed tracked update or message that the user is not authorized to see. A feed of a record can be subject to the same access rules as the parent record.
In one embodiment, access rules can be used to prevent subscription to a record that the user cannot see. In one implementation, a user can see a record, but only some of the fields. In such instances, only items about fields that the user can access may be displayed. In another embodiment, sharing rules and FLS are applied before a feed item is being added to a feed. In another embodiment, sharing rules and FLS are applied after a feed item has been added and when the feed is being displayed. When a restriction of display is mentioned, the enforcement of access rules may occur at any stage before display.
In some implementations, the access rules can be enforced when a query is provided to a record or a user's profile to obtain feed items for a news feed of a user. The access rules can be checked and cross-references with the feed items that are in the feed. Then, the query can only return feed items for which the user has access.
In other implementations, the access rules can be enforced when a user selects a specific profile feed or record feed. For example, when a user arrives on a home page (or selects a tab to see the record feed), the database system can check to see which feed items the user can see. In such an embodiment, each feed item can be associated with metadata that identifies which field the feed item is about. Thus, in one embodiment, a feed tracked update is not visible unless the associated record and/or field are visible to the user.
In one example, when a user accesses a feed of a record, an access check can be performed to identify whether the user can access the object type of the record. In one implementation, users are assigned a profile type, and the profile type is cross-referenced (e.g. by checking a table) to determine whether the profile type of the user can see the object type of the record.
In some embodiments, access to specific records can be checked, e.g., after it has been determined that the user can access the record type. Rules can be used to determine the records viewable by a user. Such rules can determine the viewable records as a combination of those viewable by profile type, viewable due to a profile hierarchy (e.g. a boss can view records of profile types lower in the hierarchy), and viewable by manual sharing (e.g. as may be done by an owner of a record). In one embodiment, the records viewable by a user can be determined beforehand and stored in a table. In one implementation, the table can be cross-referenced by user (or profile type of a user) to provide a list of the records that the user can see, and the list can be searched to determine if the record at issue is among the list. In another implementation, the table can be cross-referenced by record to determine a list of the profile types that can access the record, and the list can be searched to find out if the requesting user is in the list. In another embodiment, the records viewable by a user can be determined dynamically at the time of the access check, e.g., by applying rules to data (such as user profile and hierarchy information) obtained from querying one or more tables.
In other embodiments, checks can be made as to whether a user has access to certain fields of a record, e.g., after it has been determined that the user can access the record. In one aspect, the access check on fields can be performed on results already obtained from the database, to filter out fields that the user cannot see. In one embodiment, the fields associated with retrieved feed items are determined, and these fields are cross-referenced with an access table that contains the fields accessible by the user (e.g. using the profile type of the user). Such an access table could also be a negative access table by specifying fields that the user cannot see, as can other access tables mentioned herein. In one embodiment, the field level access table is stored in cache at a server.
In one embodiment, a user can see the same fields across all records of a certain type (e.g. as long as the user can see the record). In one implementation, there is a field level access table for each object type. The access table can be cross-referenced by user (e.g. via profile type) or field. For example, a field can be identified along with the profile types that can see the field, and it can be determined whether the user's profile type is listed. In another example, the user can be found and the fields to which the user has access can be obtained. In another embodiment, the accessible fields could be specified for each record.
Regarding profile feeds and news feeds, a first user may perform an action on a record, and a feed tracked update may be generated and added to the first user's profile feed. A second user who is allowed to follow the first user may not have access rights to the record. Thus, the feed tracked update can be excluded from a news feed of the second user, or when the second user views the first user's profile feed directly. In one embodiment, if a user is already on the detail page, then another access check (at least at the record level) may optionally not be performed since a check was already done in order to view the detail page.
In some embodiments, for profile feeds and news feeds, the feed items can be organized by object type. IT can then be determined whether the requesting user can access to those object types. Other access checks can be done independently or in conjunction with these access checks, as is described above.
B. API Implementation
Various embodiments can implement the access rules in various ways. In one embodiment, all recent feed items (or more generally events) are retrieved from a feed that is ready for display (e.g. after a feed generator performs formatting) or a table. Then, bulk sharing checks can be applied on the retrieved items. The viewable feed items of the most recent set can then be displayed.
In another embodiment regarding a profile feed, for non-VAD (view all data) users, i.e. users who can see everything, certain functions can be overridden. In one implementation, a FROM clause in a query can be overridden to be a pipelined function, e.g., with different parts of the query being operated on at the same time, but with different operations of a pipeline. This pipeline function can be given a row limit and the maximum number of sharing checks to run. It can loop, selecting the next batch of rows, run sharing checks against them in bulk, and pipe back any IDs which are accessible. In one aspect, in nearly all cases, the user feed can contain accessible IDs so the sharing checks can pass on the first loop. However, it is possible the sharing may have changed such that this user's access is greatly reduced. In one worst case, embodiments can run sharing checks on up to the maximum number of sharing check rows (e.g. a default 500) and then terminate the function with the IDs which passed so far, possibly zero. Such an example includes a low level person viewing profile feed of CEO.
In some embodiments, if the user has a small number of subscriptions (e.g. <25), then embodiments can first run sharing checks on those IDs and then drive the main query from those accessible IDs, as opposed to a semi-join against the subscription and running sharing checks on the resulting rows. In other embodiments, FLS is enforced by building up a TABLE CAST of the accessible field IDs from the cached values. A main query can then join against this table to filter only accessible fields.
XI. Filtering and Searching Feeds
It can be possible that a user subscribes to many users and records, which can cause a user's news feed to be very long and include many feed items. In such instances, it can be difficult for the user to read every feed item, and thus some important or interesting feed items may not be read. In some embodiments, filters may be used to determine which feed items are added to a feed or displayed in the feed, even though a user may be authorized to see more than what is displayed. Section VII.E also provides a description of filtering based on criteria.
In one embodiment, an âinterestingnessâ filter can function as a module for controlling/recommending which feed tracked updates make it to the news feed when the number of items that a user subscribes to is large. In one such embodiment, a user can specify a filter, which is applied to a user's news feed or to record and profile feeds that the user requests. Different filters can be used for each. For example, processing can be done on the news feed to figure out which feed tracked updates are the most relevant to the user. One embodiment can use an importance weight and level/ranking, as described herein. Other embodiments can include a user specifying keywords for a message and specifying which records or users are most important.
In one embodiment, a filter can be used that only allows certain feed items to be added to a feed and/or to be displayed as part of a feed. A filter can be used such that the removal or non-addition of certain feed items automatically occur for any new feed items after the filter criteria are entered. The filter criteria can also be added retroactively. The criteria of such a filter can be applied via a query mechanism as part of adding a feed item to a table or displaying a feed, as described in sections above. In various embodiments, a user can directly write a query or create the query through a graphical user interface.
 FIG. 14 is a flowchart of a method 1400 for creating a custom feed for users of a database system using filtering criteria according to embodiments. Any of the following steps can be performed wholly or partially with the database system, and in particular by one or more processor of the database system.
In step 1410, one or more criteria specifying which feed items are to be displayed to a first user are received from a tenant. In one embodiment, the criteria specifies which items to add to the custom feed. For example, the criteria could specify to only include feed items for certain fields of a record, messages including certain keywords, and other criteria mentioned herein. In another embodiment, the criteria specifies which items to remove from the custom feed. For example, the criteria could specify not to include feed items about certain fields or including certain keywords.
In step 1420, the database system identifies feed items of one or more selected objects that match the criteria. The feed items can be stored in the database, e.g., in one or more of the tables of FIG. 9A. In one embodiment, the one or more selected objects are the objects that the first user is following. In another embodiment, the one or more selected objects is a single record whose record feed the first user is requesting.
In step 1430, the feed items that match the criteria are displayed to the first user in the custom feed. The generation of text for a feed tracked update can occur after the identification of the feed items (e.g. data for a field change) and before the display of the final version of the feed item.
In one embodiment, the criteria are received before a feed item is created. In another embodiment, the criteria are received from the first user. In one aspect, the criteria may only used for determining feeds to display to the first user. In yet another embodiment, the criteria are received from a first tenant and applies to all of the users of the first tenant. Also, in an embodiment where a plurality of criteria are specified, the criteria may be satisfied for a feed item if one criterion is satisfied.
Some embodiments can provide mechanisms to search for feed items of interest. For example, the feed items can be searched by keyword, e.g., as entered by a user. As another example, a tab (or other selection device) can show feed items about or from a particular user. In one implementation, only messages (or even just comments) from a particular user can be selected.
In another embodiment, a user can enter search criteria so that the feed items currently displayed are searched and a new list of matching feed items is displayed. A search box can be used to enter keywords. Picklists, menus, or other mechanisms can be used to select search criteria. In yet another embodiment, feed comments are text-indexed and searchable. Feed comments accessibility and visibility can apply on the search operation too.
In one embodiment, when a user performs a search of feeds, there can be an implicit filter of the user (e.g., by user ID). This can restrict the search to only the news feed of the user, and thus to only record feeds and profile feeds that the user is subscribed. In another embodiment, searches can also be done across feeds of users and records that are not being subscribed.
Besides searching for feed items that match a criteria, one also could search for a particular feed item. However, in one embodiment, a user cannot directly query a feed item or feed comment. In such an embodiment, a user can query to obtain a particular profile or record feed, and then navigate to the feed item (e.g. as child of the parent feed). In another embodiment, the relationship from a feed to its parent entity (e.g. a record or user profile) is uni-directional. That is a user can navigate from the feed to the parent but not vice versa.
In one embodiment, a user can directly query the child tables, e.g., comment table 930. Thus, a user could search for comments only that user has made, or comments that contain certain words. In another embodiment, a user can search for a profile feed of only one user. In yet another embodiment, a user can search for profile feeds of multiple users (e.g. by specifying multiple user names or IDs), which can be combined into a single feed.
XII. Maintaining Records for Follower's Feeds
If every feed item is stored and maintained on a follower's feed or even in the profile and/or record feeds, the amount of data to be stored could be massive, enough to cause storage issues in the system. In one embodiment, the N (e.g. 50) most recent feed items for each feed are kept. However, there can be a need to keep certain older feed items. Thus, embodiments can remove certain feed items, while keeping others. In other embodiments, old feed tracked updates may be archived in a data store separate from where recent feed items are stored.
In some embodiments, feeds are purged by a routine (also called a reaper) that can remove items deemed not worthy to keep (e.g. old items). Any underlying data structures from which feed items are created can also be purged. In one embodiment, the reaper can remove certain items when new items are added (e.g. after every 5th item added). As another example, feed items may be deleted synchronously during the save operation itself. However, this may slow down each save operation. In one embodiment, however, this may be better than incurring a larger cost when the items are removed at longer intervals. In another embodiment, the reaper can run periodically as a batch process. Such routines can ensure that a table size does not become too large. In one aspect, a reaper routine can keep the event hifeed tracked update table relatively small so the sharing checks are not extremely expensive.
In various embodiments, the reaper can maintain a minimum number (e.g. 50 or 100) of feed items per record, maintain a minimum number of records per user (e.g. per user ID), and not deleting feed items (or entire records) which have comments against it. Such embodiments can ensure that the detail page and profile page have sufficient data to display in a feed. Note that the sharing checks for feed queries can cut down the number of records further for users with less access. Thus, the number of records finally displayed for specific users can be significantly less than a minimum number for a specific profile or record feed. In one embodiment, a reaper deletes data that is older than a specified time (e.g. 6 months or a year).
In one embodiment, the reaper can perform the deletion of feed items (purging) as a batch up deletion. This can avoid deletion of large number of records that may lead to locking issues. In another embodiment, the reaper can be run often so that the table does not become difficult to manage (e.g. size-wise). In this way the reaper can work on a limited set of records. In one implementation, the reaper may have logic that deletes certain items (e.g. by an identification) from tables (e.g. those in FIG. 9A), or sections of the tables.
XIII. Structured Data in an Information Feed
Some implementations disclosed herein provide for the uploading of structured data, described in greater detail below, to an organization-specific social networking system. The social networking system selectively publishes updates in the feed of a user or record related to the uploaded data.
In some embodiments, users may quickly build a useful application even on an unfamiliar platform. Users may rapidly create applications loaded with corporate data from formats such as Excel and Access databases. Some embodiments may include business related templates such as to-do lists and sales project management.
In some embodiments, business users can easily move their structured data that is now in Excel or in other forms to a cloud-based database that is collaborative, real-time, and/or mobile. Platform features may be enabled on imported objects. An imported object may be packagable. That is, the imported database object may be âpackagedâ into an application such as an org-level application that can be re-used in the future.
In some embodiments, fewer requests may be needed at an IT department, since business users may be able to create and manage their own databases in the cloud. This in turn may allow the IT department to focus on tasks that are higher priority and more complex than creating and customizing objects for various internal departments.
In some embodiments, an administrator may have access to and/or control over user-uploaded objects. In some embodiments, an administrator may have the right to enable and/or disable data import for users.
Some embodiments may provide a strategy for dealing with desktop database management system proliferation. Organizations may have hundreds or thousands of desktop databases that are ungoverned, unmanaged, and/or used by single users instead of shared widely. Desktop databases can lead to serious privacy concerns due to lack of governance. However, it is anticipated that prohibiting business units from creating desktop databases may not work. For example, users could find an alternative with commercial or open source tools. Instead, automated tools may be provided to allow users to move existing databases into the cloud. Single instances of such desktop databases may be consolidated into to larger, multi-database instances for simplified security, management, and/or governance.
Viral marketing describes a strategy that encourages individuals to pass on a marketing message to others, creating the potential for exponential growth in the message's exposure and influence. Like viruses, such strategies take advantage of rapid multiplication to explode the message to thousands, to millions. In some embodiments, giving business users the power to use an on-demand computing environment platform with limited IT investment along with news feed on updates to their data may encourage viral adoption of the platform. That is, the viral nature of social networking files may be applied to data.
In some embodiments, users of an organization-specific social network may log into a limited portion of an on-demand service environment used to provide the social network. Some users may not have prior experience with user interface components such as tabs, list views, etc. Accordingly, a grid view may be provided for allowing users to upload and/or edit objects that have data and/or metadata. Alternately, or additionally, users may be able to toggle back-and-forth between grid view and more traditional pages within the on-demand service environment, such as detail and edit pages.
In some embodiments, structured data may include references to other data stored within an on-demand computing services environment with which the social networking service is provided. For example, the on-demand computing services environment may provide access to data objects such as User, Contact, Case, or Account within the context of a Customer Relations Management (CRM) service. In this case, the structured data may include a âCaseâ column, in which each of the data fields stores a value corresponding to a Case object accessible via the computing services environment.
In some embodiments, users may be able to manage their structured data in one place and relate it to existing CRM data and other business data. Users may be able to switch less between applications. The database creation and sharing process may have more transparency due to news feeds and push of information. These and other changes may cause users to become significantly more efficient.
 FIG. 15 is a flowchart of a method 1500 for performing a structured data lifecycle according to one or more embodiments. The method 1500 shows some of the operations related to receiving, processing, analyzing, and storing structured data for use in an organization-specific social networking environment. Additional details regarding many of these operations are discussed with respect to FIGS. 16-18.
In some embodiments, the method 1500 may be performed at least in part at a computing device configured to provide computing services associated with an on-demand computing services environment and/or an organization-specific social networking system. For instance, one or more operations shown in FIG. 1500 may be performed at least in part on application server 288 shown in FIG. 2B. Additionally, or alternately, one or more operations may be performed at a client machine in communication with a server. For instance, the client machine may execute a rich client interface for interacting with the computing services environment.
At 1502, structured data is received. In some embodiments, the structured data may be received at a computing device associated with the computing services environment used to provide the organization-specific social networking system. Alternately, or additionally, the structured data may be received at a computing device associated with an organization accessing the organization-specific social network.
In some embodiments, the data may be received in various ways. For instance, the data may be uploaded to the computing services environment as a file. The file may be selected by a user from a local storage device during the upload process. As another example, the data may be copied and pasted from a file into a textbox or other user interface displayed in a web page provided by the computing services environment. As yet another example, data may be retrieved by computing services environment via a network (e.g., Internet) link provided to the computing services environment.
In some embodiments, the types of structured data that may be received include, but are not limited to: comma separated values (CSVs), tab separated values (TSVs), MicrosoftÂ® ExcelÂ® data, custom XML data, MicrosoftÂ® AccessÂ® Database data, OracleÂ® Database data, Structured Query Language (SQL) data, fixed width data, GoogleÂ® Documents spreadsheet data, OpenOfficeÂ® spreadsheet data, Salesforce.comÂ® report data, or any other type of structured data. In some embodiments, the types of structured data may include any data that can be structured in a tabular (i.e. table) format having rows and columns. If the data were to represent a table, then each column may be a field and each row may be a data record row. Alternately, some types of non-tabular data may be supported.
In some embodiments, the data upload procedure may be selected based on the type of data being uploaded. If MicrosoftÂ® AccessÂ® data is detected, for instance, then a data upload procedure for reading MicrosoftÂ® AccessÂ® data may be used to receive the data. The data type may be determined by analyzing a file extension, a Multipurpose Internet Mail Extension (MIME) type, a content type, or other metadata associated with the data. Alternately, or additionally, the data type may be identified by analyzing the data itself. For example, the upload procedure may detect a frequent and regular occurrence of commas within the data and deduce that the file type is a CSV text file.
In some embodiments, the data may be received in a compressed form. For example, data may be received as a file compressed using the ZIP compression and archive format.
In some embodiments, the type of data may be determined at least in part by the computing services environment upload procedure. For example, the upload procedure may examine a file type associated with the received data, a MIME/Type of a file, metadata received with the data, or other information to automatically determine a data type.
In some embodiments, a user may specify metadata or other information for facilitating the receipt of the data. For instance, the user may specify a character that acts as a delimiter between values in the received data. The delimiter may be, for example, a comma, a hyphen, a tab, or any other character.
In some embodiments, the data may be formatted. Formatting may include colors, font size, font type, or any other display-related functionality. Alternately, formatting may not be supported. In some embodiments, formatted data (e.g., spreadsheets) may be accepted for importing but may be stripped of formatting before being stored in the system. Alternately, certain limited formatting may be accepted, and imported data may be stripped of extraneous formatting beyond that permitted by the system.
 FIG. 19 shows an image of a user interface component that includes structured data that has been received at the computing services environment. FIG. 19 includes a database title 1902, a database header row 1904, and a data row area 1906. The data row area 1906 includes the data entries 1908, 1910, and 1912.
The database title 1902 indicates that the database relates to recent event vendors. In some embodiments, a user may specify the database title when uploading the structured data. Alternately, or additionally, the system may suggest a title for the data based on the contents of the data, a data record stored in the system that is related to the structured data, or other information.
The database header row 1904 shows the titles for each column of data in the database. In FIG. 19, the titles include Vendor Name, Contact, Vendor Deliverables, and other titles.
The data row area 1906 may include various numbers of data rows, with each row including data for a given data record. In some embodiments, data rows may include data entries for each column provided in the header row 1904. The data entries may include various types of data. For example, the data entry 1908 includes a reference to a different data entry, a contact object associated with a person named Frank Miller. The data entry 1910 includes text indicating that the Vender Deliverable for that Vendor is âFurnitureâtables, chairs.â The data entry 1912 is blank, indicating that no data is recorded for that data entry.
Although FIG. 19 shows the rows for the structured data as including the different data records and the columns for the structured data as including the data labels for the data fields included in each data record, some embodiments may use an alternate visualization. For example, in some embodiments, the columns for the structured data may include the different data records and the columns for the structured data may include the data labels for the data fields included in each data record.
In some embodiments, the uploading process may include checking of the data by the system and editing of the data by the user uploading the data. The system may impose restrictions or requirements on data that is uploaded, and the user may need to edit or correct the data so that it meets the requirements or restrictions. These considerations are discussed in additional detail with respect to FIGS. 16 and 17.
At 1504, the structured data is shared. The structured data may be shared by associating the structured data with data records, individuals, groups, profiles, or applications that form or participate in the organization-specific social networking system.
In some embodiments, the sharing of the structured data may occur automatically by actions of the system. For example, if structured data is uploaded to a particular group within the social networking system, then the structured data may automatically be shared with all members of the group.
In some embodiments, the sharing of the structured data may occur based on selections of a user. For example, the user uploading the structured data may indicate that the structured data should be shared with certain individuals or associated with an application provided by the on-demand computing services environment.
In some embodiments, the shared structured data may appear in various locations within the social networking system. For example, the structured data may appear in a list of recent data files associated with a group or profile. As another example, the structured data may appear on a list view associated with a group or profile.
In some embodiments, the structured data as displayed in the social network locations may be viewed when a user navigates to these entities in the social networking. Alternately, or additionally, the structured data or an indication of the structured data may placed in an information feed or provided to users in some other way.
 FIG. 20 shows an image of a user interface component that includes structured data that has been shared. FIG. 20 includes information feed 2002, information post 2004, and comment 2006.
An information feed may display information related to a data record, individual, or group within the social networking environment. For instance, the information feed 2002 displays information related to the Sudden Valley Launch, an event represented as a data record within the organization-specific social network.
In some embodiments, shared structured data may appear as an information post. For example, the vender list shown in FIG. 19 appears as information post 2004. By appearing in the information feed 2002 as an information post, the structured data may be likely to be seen by users of the social networking system. In some embodiments, users may comment on the structured data. For instance, the comment 2006 shows a user named Scott Jackson commenting on the information post 2004.
In some embodiments, users may specify what types of structured data information updates they would like to receive. For instance, a user may indicate that updates related to new structured data objects, additions or deletions of data entries within structured data objects, changes to metadata, changes to existing data fields, or some combination thereof should cause updates to appear in the information feed. If there have been many changes to a database that the user is following, then only some of the changes may generate updates. For instance, the first three changes may generate updates, and the remaining changes may be available in the information feed by clicking a âshow moreâ button.
 FIG. 21 shows an image of a user interface component that includes structured data that has been shared. FIG. 21 includes information posts 2102 and 2004. The information post 2102 includes a description area 2104, a view link 2106, an edit link 2108, and a data icon 2110.
In some embodiments, the description area 2104 may provide an indication regarding the subject of the information post. In some embodiments, the information posts may show structured data that has been added or edited. For instance, information post 2004 shows a database that has been added to the system, while information post 2102 shows a database that has been edited to include a new data record.
In some embodiments, information posts may include links allowing a user to interact with the structured data. Post 2102, for instance, includes the edit link 2108 and the view link 2106 allowing a user to edit or view the structured data. These links may allow editing directly in the information feed or may open the structured data in a separate user interface component that allows data editing.
In some embodiments, the data icon 2110 may be a thumbnail image of the actual data contained in the structured data object. Alternately, the image may not represent the actual data contained in the structured data object.
At 1506, collaboration on the shared data may occur. In some embodiments, the collaboration on the shared data may include actions taken by users other than a user who uploaded the data. The collaborative actions may include, but are not limited to: editing the metadata describing or providing structure to the structure data, editing the data itself, and editing permissions or properties defining how the structured data is shared or accessed.
In some embodiments, structured data uploaded into the system may be used to create new information or data visualizations. For example, FIG. 22 shows an image of a user interface component displaying structured information. FIG. 22 includes a structured data area 2202, a data visualization area 2204, and a data visualization object 2206.
In some embodiments, the structured data area 2202 may display structured data that has been uploaded into the system, such as the structured data shown in FIG. 19. This data may be displayed, combined, separated, or otherwise manipulated using data visualization objects displayed in the data visualization area 2204. For instance, the data visualization object 2206 displays a budget meter. Based on the total price of the services of venders in the vender list displayed in the structured data, the budget meter will show how close the current budget is to a total budget. Data visualization objects may reflect one or more formulas. In FIG. 22, for instance, the data meter reflects a summation of the values in the Total Price column of the database. Thus, if a value in the Total Price column were to be changed, the data visualization object may be updated to reflect the changed value of the summation formula. In some embodiments, many such data visualization objects may be created by a user or may be provided by the computing services environment and selected by the user.
At 1508, the shared data may be archived or deleted. Archiving or deleting the shared data may include operations for storing the shared data to a long-term storage medium, creating a custom database object for containing the shared data, or removing data from appearing in the social networking system.
In some embodiments, operations related to archiving or deleting the data may occur at the request of the user. For instance, a user may request that data be deleted or saved.
In some embodiments, operations related to archiving or deleting the data may occur automatically. For example, the system may automatically archive or delete data that has not been edited for a designated period of time or that has been in the system for a designated length of time.
 FIG. 16 is a flowchart of a method 1600 for processing structured data according to one or more embodiments. The method 1600 may be used to receive, edit, share, collaborate on, archive, delete, and/or store structured data. In some embodiments, the method 1600 may be performed at a computing device used to provide social networking services and/or on-demand computing services, such as the computing devices discussed in relation to FIGS. 1A-2B. The computing device may be in communication with a client machine accessing the social networking services and/or on-demand computing services. The method 1600 may be initiated when data is received by the computing device, when triggered by a user, or when triggered by computing programming instructions executed at the computing device.
Data is received into the computing services environment at 1602. In some embodiments, the receipt of the data 1602 may be substantially similar to the receipt of the data at operation 1502 described with respect to FIG. 15.
At 1604, a determination is made as to whether to edit the received data. In some embodiments, the determination may be made automatically. For example, the data may be analyzed by the system, and the analysis may indicate an inconsistency, a data typing error, a missing column header, missing metadata, missing data, or any other problem. Fixing the detected problem may be deemed optional or mandatory, depending on the requirements of the system and the type of problem detected. When a problem is detected, a user may be notified and/or provided with an interface to edit the data. Verification of uploaded data is discussed in additional detail with respect to FIG. 17.
In some embodiments, the determination made at 1604 may be made by a user. A user may review the uploaded data and make a decision to edit the data. For instance, the data may contain errors or omissions or may have missing or erroneous metadata.
When receiving edited data, various editing and customization features may be supported. For instance, a user may be able to add new columns (fields), delete columns, change the order of columns, modify layouts, create filtered list views, share structured data, report structured data, add validation rules, and/or perform other types of data manipulation.
In some embodiments, some customizations or capabilities that might otherwise be possible using the platform may not be available to certain users. For example, end users may not be able to add custom computing programming code or custom markup to databases created using the structured data techniques described herein. However, in alternate embodiments, any of these features may be made available to any users.
At 1606, edited data is received. The receipt of edited data may include any operations for receiving edited data. For instance, a user interface may be provided via a web browser or stand-alone application. The user interface may be capable of receiving input at a client machine and transmitting the received input to a computing device used to process the structured data.
 FIGS. 23 and 24 show images of structured data displayed in a user interface component provided according to one embodiment. FIGS. 23 and 24 include data header 2302, data entry 2304, and data entry 2306.
The structured data shown in FIGS. 23 and 24 is in the process of being edited. In FIG. 23, a value is being typed in for the data header 2302. In FIG. 24, the edited data header 2302 has the value of Status. Additionally, the status for the vender We Have People has been set to Confirmed in data entry 2304, while the status for the vender Gelb Music Company has been set to Deposit paid in data entry 2306.
At 1608, the structured data is published. In some embodiments, publishing the structured data may include any operations for referencing the data within the social networking system and/or computing services environment. For instance, the structured data may be uploaded to a particular account, profile, group, or other data record that is accessible via the social networking system. In this case, publishing the structured data may include inserting a reference to the structured data in an information feed or list associated with the data record. Users accessing the data record may then be able to see that the data record is linked to the structured data.
At 1610, the structured data is shared within the social networking system. In some embodiments, the structured data may be shared as a whole, rather than on an entry by entry basis. That is, a user who has permission to view or edit a structured data file may have the ability to view or edit all of the data in the file. Alternately, permissions may be assigned such that a user may be limited to viewing or editing only certain portions of a structured data file.
In some embodiments, one or more of the following sharing rules may be imposed. If a user posts structured data on a record, the user must have access to the record to see the structured data. If the user posts structured data on the user's feed, the structured data is public to the user's organization and the user can see the structured data. If the user posts structured data on a public collaboration group, regardless if the user is a member, the user can see the structured data. If the user posts structured data file on a private collaboration group, the user must have access to the private group to see the structured data. For cross-posted structured data, such as structured data from content or structured data posted to various locations, the user can see the structured data if the user has permission to see it via a sharing rule such as one of the aforementioned sharing rules.
In some embodiments, a user may have permission to view the structured data but not to edit the structured data. In some embodiments, a user may be granted permission to view and/or edit all structured data. In some embodiments, permission to modify the schema of structured data (e.g. adding a new column, deleting a column or changing the type or name of the column) may be granted to anyone that has edit access and the owner.
The preceding examples of sharing rules are not intended to be limiting. Rather, the provider of the computing services environment or a user associated with an organization accessing the computing services environment may strategically determine sharing rules based on factors such as privacy and security concerns, data protection, and the types and numbers of users who may be using the system.
At 1612, the shared data may be collaborated on. In some embodiments, the collaboration performed at 1612 may be substantially similar to collaboration performed at operation 1506 shown in FIG. 15. The collaboration may include any operations related to editing the shared data, sharing the data with more or fewer users, linking or unlinking the shared data to data records, or other forms of data manipulation.
At 1614, a determination is made as to whether to promote the shared data to a custom object. In some embodiments, a custom object may be a technique for storing the data in a storage medium such as a database that allows more complex and/or enduring interaction with or manipulation of the data. For example, when stored as a custom object, the data may be more permanent than when stored only as structured data. As another example, data stored as a custom object may be divided on a row-by-row basis for the purposes of assigning viewing or editing permissions. As yet another example, data stored as a custom object may be more easily displayed or manipulated within the computing services environment via on-demand computing services.
In some embodiments, promoting the shared data to a custom object may increase the platform-level functionality that may be used in conjunction with the data. For instance, the system may allow custom database objects to be used in conjunction with workflows, report generation, custom programming language instructions, custom markup, or other platform-level functionality. Alternately, the shared data may be promoted to a custom object for another reason, and some or all of the platform functionality may be available even for data that has not been promoted to a custom object.
In some embodiments, the determination made at 1614 may be made by a user. For example, a user may request that the shared data should be promoted into a custom object. Alternately, or additionally, the determination may be made automatically. For instance, the system may suggest that shared data be promoted to a custom object if one or more criteria are met. These criteria may include a length of time that the data has been in the system, an amount or frequency of viewing or editing of the data activity that has occurred, a size of the data, or any other factors.
If it is determined to promote the shared data to a custom object, then at 1616 the shared data is promoted. In some embodiments, promoting the shared data to a custom object may include changing a storage structure of the shared data within a database. Implementation details regarding the storage of shared data in a database, including the promotion of shared data to a custom object, are discussed in more detail with respect to FIG. 18.
In some embodiments, at least some of the operations shown in FIG. 16 may be performed at least in part by an administrator. For example, a level of administrative authority may be required to create a custom object at 1616. In this case, a user may request that the shared data be promoted to a custom object at 1614, and an administrator may respond to the request by actually creating the custom object at 1616. Alternately, the system may be configured such that any of the operations shown in FIG. 16 may be performed by the system itself automatically or in accordance with requests by end users.
At 1618, a determination is made as to whether to archive or delete the shared data. In some embodiments, the determination may be made by a user. For instance, a user acting as an owner or editor of the structured data may be able to request that the data be archived or deleted. Such a request may be made after the data has served its purpose.
In some embodiments, the determination may be made at least in part by the system storing the data. For instance, the system may determine that a database has not been edited or accessed for a designated period of time, such as for 6 months. Then, the system may transmit a message to a user such as an administrator, an owner of the database, or an editor of the database asking if the shared data may be archived or deleted.
In some embodiments, the types of actions that may be taken by a user when collaborating on the shared data may be limited to a permission or role assigned to the user or a group in which the user is a member. For instance, in the case of a database object posted to a group, modification of the metadata and/or data may be limited to an owner of the group, an owner of the database object, or other users designated by the database object owner or group owner. Other users may be limited to viewing the database object. The types of limitations to impose may be strategically selected based on factors such as the desired level of security, the desired level of data protection, the size of the group, and the members of the group. Further, as discussed with respect to FIGS. 27-29, sharing permissions may be granular, adjustable, and customizable.
At 1620, the shared data is deleted. The operations performed when the shared data is deleted may be strategically determined based on factors such as the operating procedures for the social networking system. For instance, one or more of the following operations may be performed: the data may be deleted from a storage device, references to the data may be removed from the social networking system, indications of the data may be removed from information feeds within the social networking system, the data may be unlinked from data records within the computing services system, the data may be removed from a cache, and/or the data may be moved to a less accessible storage system.
At 1622, the shared data is archived. Archiving the shared data may include performing any operations for storing the shared data so that it may later be retrieved. In some embodiments, the archived data may be transferred from an easily-accessed storage medium, such as a cache, to a long-term storage medium, such as an archival storage system. In some embodiments, references to the archived data may be removed from the social networking system and/or the data records displayed in the computing services environment. The archived data may be retrievable later by submitting a request or by navigating to a list of archived data. In some embodiments, the archived data may not actually be moved, and instead may simply be removed from lists of active content (e.g., for a particular data record).
 FIG. 17 shows a structured data analysis method, performed in accordance with one embodiment. Some portions of the structured data analysis method shown in FIG. 17 may be similar to the methods shown in FIGS. 15 and 16. Accordingly, FIG. 17 is described primarily with respect to additions and differences not shown in FIGS. 15 and 16.
At 1702, the data is received for importing into the social networking system. The receipt of data is also discussed with reference to operations 1502 and 1602 shown in FIGS. 15 and 16. When the data is received, it may be associated with a data record in the computing services environment. For instance, the data may be received after a user clicks an âimportâ button while viewing a data record.
At 1704, the received data is analyzed to create a metadata structure. In some embodiments, the metadata may include any information related to structuring, typing, naming, classifying, or otherwise providing context to the data.
In some embodiments, the metadata may include column names. The column names may be identified by selecting the first data value in each column of the uploaded data. Alternately, the uploaded data may specify the column names or other metadata through data formatting, XML, or some other mechanism. As discussed with respect to FIGS. 15 and 16, the data upload process may be strategically determined based on the type of data being uploaded.
In some embodiments, a data column may be associated with a data field type. The data field type may specify a classification identifying one of various types of data that determines the possible values for that type, the operations that can be done on that type, and/or the way the values of that type are stored.
In some embodiments, some data columns may be strongly typed. A data column may be associated with a data type, and each value of a data field corresponding to that data column may need to comply with the data type. Alternately, or additionally, some data columns may be weakly typed. The data values may be subject to implicit type conversion or overloading.
In some embodiments, a data entry having a data field that does not comply with the data type of its respective column may not be saved. Alternately, such a data entry may be saved. For instance, the data entry may be flagged as having an error, and the error may be corrected during editing.
In some embodiments, a data column may be associated with more than one data field type. For instance, a data column may be configured to accept numbers or text values.
In some embodiments, the available data field types may be strategically determined based on uses of the structured data. For example, the available field types may be determined based on commonly stored values in database, based on the functionality of the social networking system, or based on likely uses of the structured data system.
In some embodiments, one or more data field types may be supported. Data field types other than those in the following lists may be supported, and not all of the data field types included in the following lists need be supported. The available data field types may include text values, uniform resource indicator (URI) values, World Wide Web link values, e-mail address values, phone number values, currency values, numeric values. The available data field types may include a choice value restricted to one of a list of choices, a checkbox value restricted to a binary value (e.g., yes/no, true/false, on/off), a user value restricted to an identifier of a user of the social networking system, an attachment value that contains a reference to an uploaded file, a duration value that specifies a period of time, a date and/or time value formatted according to a calendar date and/or time value, a location value restricted to an address or other indication of location, a list of entries restricted to a plurality of entries from a specific category, a link value restricted to a link to another data entry of a specific category.
In some embodiments, data types may support restrictions. For instance, a number data type may be limited to positive numbers, integers, or some other number type. As another example, a text data type may be limited to text strings shorter than a designated number of characters.
In some embodiments, a data field type may include a foreign database key within the computing services environment. The foreign database key data type may be limited to database keys associated with records stored in a database accessible via the computing services environment. For instance, the foreign database key data type may be limited to a database key associated with an Opportunity or Case database object accessible via the computing services environment.
In some embodiments, a data field type may be identified by determining that many or most data values in a data column are of a particular data field type. The threshold for identifying a data column as having a particular data field type may be a percentage value (e.g., 95% of the values) or a numerical value (e.g., all values but 5). The thresholds for identifying data types may be strategically determined based on the type of data being uploaded, the technical ability of the user uploading the data, or any other considerations. Exceptions to the identified data field type for a data column may be identified as errors at 1708.
In some embodiments, the metadata may include formulas. In some instances, formulas may be performed at the column level. For instance, one column in a database may be a âunit price,â while a second column may be a ânumber of units.â In this case, a third column may be a âtotal price.â The third column may be defined not as independently provided values, but rather as the product of the first and second columns. In some embodiments, formulas may be provided at the cell level. That is, one data field may be defined as the product of two other data entries, irrespective of operations and values for other data fields in the same columns.
At 1706, the metadata structure is applied to the received data to create structured data. In some embodiments, the received data may be separated into a plurality of data entries. Each data entry may have a plurality of data fields. At least some of the data fields may be assigned a respective data value. However, some data fields may not have a value.
In some embodiments, the data types identified at 1704 may be associated to the data fields. Assigning the types to the data fields may involve checking each of the data fields to determine whether the data fields correspond with the assigned data type.
In some embodiments, applying the metadata structure to the received data may include establishing a data object for storing in a database. That is, the received data may be structured to facilitate storing in a database.
In some embodiments, applying the metadata structure to the received data may include establishing column headers, establishing a label for the received data, or establishing any other contextual information for the received data.
In some embodiments, applying the metadata structure to the received data may include verifying foreign database keys. For example, a column in the received data may include foreign database keys corresponding to database entries stored elsewhere in the database. These foreign database keys may be checked against the actual database to determine whether the foreign database keys are valid.
In some embodiments, a default data type may be used when a more specific data type is not determined. For instance, a data column that includes different data fields with values that include numbers, text, currency, and dates may be assigned a data type of âtext.â
At 1708, a determination is made as to whether the structured data contains errors. In some embodiments, the determination may be based at least in part on the application of the metadata structure to the received data at 1706. For example, mismatches between data values and data field types may be flagged as errors in 1708.
In some embodiments, determining whether the structured data contains errors may include requesting input from a user. For instance, the data and metadata may be presented to the user and the user may be requested to identify any errors. The errors may include errors present in the data as originally uploaded (e.g., missing values) or errors introduced during the upload process (e.g., incorrectly identified data field types or column headers).
In some embodiments, determining whether the structured data contains errors may include comparing the structured data against one or more limitations or requirements imposed by a provider of the computing services environment or the social networking system. For example, the system may impose a limit of between 1 and 1,000,000 data rows on an upload and a limit of between 1 and 1,000,000 data columns on an upload.
In some embodiments, limits may be imposed for the total size of the structured data object. Alternately, or additionally, limits may be imposed on individual data uploads. In the case of limits on individual data uploads, a user may upload data beyond the limits by breaking the data into chunks that each fall below the limits.
In some embodiments, determining whether the structured data contains errors may include comparing the structured data against one or more validation rules. Validation rules may specify properties for the values stored in data entries and data fields. For instance, a validation rule may specify that a certain data field must have a value for the data entry associated with that data field to be saved. As another example, a validation rule may specify a set of acceptable values for a given data field.
 FIG. 25 shows an image of a user interface in which a validation rule is established, displayed in accordance with one embodiment. FIG. 25 includes a data record identifier 2502, a data record field 2504, and data record values 2506, 2508, 2510, and 2512.
The linkage between the data record 2502 and the data record field 2504 indicates that each data record in the structured data that has a value for Vender Name should also have a value for the status data record field 2504. The linkages between the status data record field 2504 and the data record values 2506, 2508, 2510, and 2512 indicates that the value of the status field for each data record should be one of: Researching, Negotiating, On Hold, and Order Placed.
When an error is detected, an indication of the error is provided at 1710. In some embodiments, providing the indication of the error may include any operation for logging the error and/or notifying a user of the error. For instance, a user interface component displayed at a display device may be updated to include an error message. The error message may include an indication of the type of error that has occurred, a way in which the error may be corrected, or any other information.
 FIG. 26 shows an image of a user interface in which an indication of an error is provided, displayed in accordance with one embodiment. FIG. 26 includes a data record 2602, a data record field 2604, and an error message 2606. As shown in FIG. 26, a user entered the data record 2602 as a new data record having a vendor name of Etsy. Then, the user attempted to move to a different data record without specifying a status for the status data record field 2604. Because a value is required for the status data record field 2604, the error message 2606 is displayed. As stated in the error message 2606, the data record 2602 will not be saved unless a value is entered for the status data record field 2604.
At 1712, revised data and/or metadata may be received. In some embodiments, the revised data and/or metadata may be received via a user interface for editing the data directly in a web page. Alternately, the user may edit the data and/or metadata on a local computing device and upload the edited data to the computing services environment.
In some embodiments, the revised data and/or metadata may include changes to data types provided by the system. For instance, the system may determine that a data column has a data type of number if all or the majority of data values included in the data column are numbers. However, a user may be able to change the data type to text if, for example, the user knows that text values will later be added to the column.
At 1714, the structured data and the metadata are stored. In some embodiments, storing the structured data and metadata may include any operations for causing the structured data and metadata to be maintained in a persistent state. For example, the structured data and metadata may be stored on a storage medium or in a storage system. The structured data and metadata may be stored within a database table of a database, such as database 22 shown in FIG. 1B. The database may be accessible via an on-demand computing services environment. Database schema for storing the structured data are discussed in additional detail with respect to FIG. 18.
In some embodiments, fixing the identified errors may not be required. For instance, a user may decide to store a database object that has errors and fix the database object later or collaborate with other users on fixing the errors.
At 1716, the structured data is published to the social networking system. Publishing the structured data to the social networking system may allow collaboration on the structured data, joint editing of the structured data, information updates regarding changes to the structured data, and other social media functionality.
In some embodiments, restrictions on viewing the database object created by uploading the structured data may be imposed. The restrictions may be based at least in part on a data record or social networking group with which the database object is associated. For instance, posting a database object to a data record within the on-demand computing services environment may require access to the record to see the file. Posting a file on a user's feed may require the file to be public to the org in order to see the file. Posting a file on a public collaboration group may allow the poster to see the file regardless of membership in the group. However, posting a file on a private collaboration group may require access to the private group to see the file.
In some embodiments, the publication of structured data to the social networking system may allow a user to specify sharing permissions for viewing and/or editing the structured data. FIGS. 27-29 show images of a user interface for publishing and sharing structured data within the computing services environment, displayed in accordance with one embodiment. FIGS. 27-29 include a sharing configuration user interface 2702, a share with people tab 2704, a share with groups tab 2706, and a share outside Chatter tab 2708.
In FIG. 27, the share with people tab 2704 is selected. Selection of the share with people tab 2704 may allow access to the sharing with people configuration area 2706. The sharing with people configuration area 2706 includes a search box 2708, a directory navigation list 2710, a list of profiles 2712, a profile indication area 2714, a profile status area 2716, and sharing settings 2718 and 2720.
The search box 2708 may be used to search for user profiles, and the directory navigation list 2710 may be used to navigate a profile directory to locate user profiles. The list of profiles 2712 shows the profiles located by search or navigation. The profile indication area 2714 shows the name and role of an individual named Fred Arthur. The profile status area 2716 shows that the sharing status of Fred Arthur for the Vender List was last updated on May 3, 2010 at 6:00 pm. The sharing setting 2718 indicates that Fred Arthur has permission to edit the Vender List. In contrast, the sharing setting 2720 shows that Christopher Battah has permission to view the Vendor List.
In FIG. 28, the share with groups tab 2706 is selected. Selection of the share with groups tab 2706 may allow access to the share with the group configuration area 2802. The share with the group configuration area 2802 includes a group search box 2804 that may be used to search for groups. The area 2802 also includes a list of groups 2804, which itself includes groups 2806, 2808, and 2810. In a manner similar to individual profiles as discussed with respect to FIG. 27, entire groups of users may be given permission to view or edit the structured data.
In FIG. 29, the share outside Chatter tab 2708 is selected. Selection of the share outside Chatter tab 2708 may allow access to the share outside Chatter configuration area 2902. Using the share outside Chatter configuration area, the structured data may be shared with people or entities who are not users of the social networking system and/or the computing services environment. These users may access the structured data by providing authentication information such as a username, an e-mail address, and/or a password. For instance, a Contractor named Brian Dills, who is identified by e-mail address, is listed at entry 1904 in the share outside Chatter configuration area 2902. This user has been assigned permission to edit the structured data at permissions configuration area 2906.
At 1718, a determination is made as to whether to create a custom database object. At 1720, the custom database object is created. The creation of a custom database object is discussed in greater detail with reference to operations 1614 and 1616 in FIG. 16 and with reference to FIG. 18.
In some embodiments, at least some of the operations shown in FIG. 17 may be performed at least in part by an administrator. For example, a level of administrative authority may be required to create a custom object at 1720. In this case, a user may request that the shared data be promoted to a custom object at 1718, and an administrator may respond to the request by actually creating the custom object at 1720. Alternately, the system may be configured such that any of the operations shown in FIG. 17 may be performed by the system itself automatically or in accordance with requests by end users.
At 1722, the structured data is maintained, archived, or deleted. In some embodiments, the maintaining, archiving, or deleting of the data performed at 1722 may be substantially similar to operations 1618, 1620, and 1622 described in relation to FIG. 16.
 FIG. 18 is a database configuration diagram 1800 of a database for storing structured data according to one or more embodiments. The database configuration diagram 1800 includes a custom object types table 1802, a custom objects data table 1804, a standard object types table 1806, a standard object definitions table 1808, and a standard objects data table 1810.
In some embodiments, a database may include a variety of standard objects. Standard objects may be used to provide standard services such as customer relations management (CRM), sales, and service. For example, standard objects may include Account, Contact, Case, Opportunity, and others.
In some embodiments, standard object types may be associated with a key prefix. The key prefix may be used to distinguish standard objects types in a table of standard objects. For example, the standard object types table 1806 links standard object types to associated key prefixes. In this table, the Account standard object type is linked to key prefix kpf7. Thus, each Account standard object may have kpf7 as the first portion of its data id.
A structured data object is referred to in FIG. 18 and the associated discussion as a Chatter Database, in part to distinguish the structured data object from the database in which it is contained and from other objects stored in that database. A Chatter Database object may be stored as a standard object. In this case, the standard object types may include a Chatter Database type. For example, the standard object types table 1806 includes the Chatter Database type, which is associated with the key prefix kpf10.
In some embodiments, a standard object may be associated with a definition. For example, the standard object definitions table 1808 includes definitions of various Chatter Database objects. As shown in the standard object definitions table 1808, each Chatter Database object definition may be associated with a definition identifier. Each definition identifier may be preceded by the Chatter Database key prefix kpf10 to indicate that the defined object is a Chatter Database.
In some embodiments, the standard object definitions table 1808 may store identifiers for individual Chatter Database objects. For example, a Vender Definitions object is linked with the Chatter Database identifier kpf10_id1.
In some embodiments, the database tables shown in FIG. 18 may include columns not shown in FIG. 18. For example, the standard object definitions table 1808 and the custom object types table 1802 may store metadata describing the standard and custom objects referenced therein. This metadata may include any metadata referred to herein with respect to the structured data, such as column headers, data field types, structured data names, sharing information, or any other related metadata. As another example, the standard object definitions table 1808 may store information such as metadata and definitions for standard objects other than the Chatter Database standard object. For instance, the standard objects table may store data types and column headers for the Account object.
In some embodiments, the data for standard objects may be stored in the standard objects data table 1810. Metadata stored in the standard object definitions table 1808 may define the columns and values for a particular Chatter Database stored in the standard objects data table 1810.
In some embodiments, a data row in the standard objects data table 1810 may be preceded by an identifier specifying the type and instance of the standard object with which it is associated. For example, the standard objects data table 1810 includes data identifiers kpf10_id1_1, kpf10_id1_2, and kpf10_id1_3, which each signify that the data in those rows belongs to the Vendor Definitions Chatter Database object.
In some embodiments, structured data objects may be stored as custom objects, as discussed with respect to operations 1614, 1616, 1718, and 1720 shown in FIGS. 16 and 17. Whereas standard objects may be defined by the provider of the on-demand computing services environment, custom objects may be defined by an entity using the on-demand computing services environment.
In some embodiments, custom objects may be similar in many ways to standard objects. For example, custom object types may be stored in a custom object types table 1802. The custom object types table 1802 may link custom object types to key prefixes used to reference data associated with those custom object types. For instance, the Contract custom object type shown in 1802 is associated with key prefix kpf1. The Contract custom object may be a Chatter Database standard object that was elevated to a custom object, as discussed with respect to FIGS. 16 and 17.
In some embodiments, the custom object types table 1802 may store metadata for some or all of the custom object types. For example, the custom object types table 1802 may store metadata for the Contract Chatter Database object stored as a custom object. The metadata may include column headers, data field types, or any other metadata describing the Chatter Database object.
In some embodiments, the custom object data table 1804 may store the data associated with custom objects defined by custom object definitions in table 1802. For example, the custom object data table 1804 includes a custom object identified by identifier kpf1_id1, which indicates that the custom object is an instance of the Contract custom object.
In some embodiments, the custom object data table 1804 may include for each custom object fields corresponding to the metadata included in the custom object types table 1802. For example, the Contract custom object may include data fields such as date signed, contract status, first contracting party, second contracting party, and contract terms.
In some embodiments, the data included in the custom object data table 1804 may include foreign keys associated with other database objects. For example, the contract terms field associated with the Contract object may store foreign keys to the Contract Terms custom object defined in the custom object types table 1802.
In some embodiments, two or more of the tables shown in FIG. 18 may be stored in the same table within the database. For example, the standard and custom object types tables 1802 and 1806 may be stored in the same database table, such as a generic object types table. As another example, the standard object data table 1810 and the custom object data table 1804 may be stored in the same database table, such as a generic data object data table.
In some embodiments, the database tables shown in FIG. 18 may be stored in a multitenant database accessible to a plurality of tenants. The multitenant database may be accessible to the tenants at least in part via an on-demand computing services environment. A multitenant database is discussed in greater detail with respect to FIGS. 1A-2B.
In some embodiments, a database configuration may be used that differs from that shown in FIG. 18. For instance, in some embodiments no distinction may be made between standard and custom objects. As another example, various kinds or classifications of database objects may be supported. As yet another example, standard and custom objects may be stored in the database in a manner different than that shown in FIG. 18. In some embodiments, the storage technique for the structured data objects may be strategically chosen based on factors such as the type, number, size, and variety of stored structured data objects.
In some embodiments, the operations described herein may be performed at a server capable of providing services for providing an on-demand computing services environment. For example, at least some of the operations described herein may be performed at the app servers 288 discussed with respect to FIG. 2B. Alternately, or additionally, operations may be performed at the query servers 282, another server shown in FIG. 2B, or in a separate server not shown in FIG. 2B.
The specific details of the specific aspects of the present invention may be combined in any suitable manner without departing from the spirit and scope of embodiments of the invention. However, other embodiments of the invention may be directed to specific embodiments relating to each individual aspects, or specific combinations of these individual aspects.
While examples of the present invention are often described herein with reference to an embodiment in which an on-demand enterprise services environment is implemented in a system having an application server providing a front end for an on-demand database service capable of supporting multiple tenants, the present invention is not limited to multi-tenant databases nor deployment on application servers. Embodiments may be practiced using other database architectures, i.e., ORACLEÂ®, DB2Â® by IBM and the like without departing from the scope of the embodiments claimed.
It should be understood that the present invention as described above can be implemented in the form of control logic using hardware and/or using computer software in a modular or integrated manner. Other ways and/or methods to implement the present invention are possible using hardware and a combination of hardware and software.
Any of the software components or functions described in this application may be implemented as software code to be executed by a processor using any suitable computer language such as, for example, Java, C++ or Perl using, for example, conventional or object-oriented techniques. The software code may be stored as a series of instructions or commands on a computer readable medium for storage and/or transmission, suitable media include random access memory (RAM), a read only memory (ROM), a magnetic medium such as a hard-drive or a floppy disk, or an optical medium such as a compact disk (CD) or DVD (digital versatile disk), flash memory, and the like. The computer readable medium may be any combination of such storage or transmission devices. Computer readable media encoded with the software/program code may be packaged with a compatible device or provided separately from other devices (e.g., via Internet download). Any such computer readable medium may reside on or within a single computer program product (e.g. a hard drive or an entire computer system), and may be present on or within different computer program products within a system or network. A computer system may include a monitor, printer, or other suitable display for providing any of the results mentioned herein to a user.
While various embodiments have been described herein, it should be understood that they have been presented by way of example only, and not limitation. Thus, the breadth and scope of the present application should not be limited by any of the embodiments described herein, but should be defined only in accordance with the following and later-submitted claims and their equivalents.